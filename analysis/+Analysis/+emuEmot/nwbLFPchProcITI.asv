function [itiFiltered, nbackFilterAllData] = nwbLFPchProcITI(data,varargin)
%nwbLFPchProc Basic processing function for EMU for iti data
%   Inputs:
%        channel - vector or matrix of channels

% example: 


[varargin, fs] = util.argkeyval('fs',varargin, 500); %sampling rate, default is 500
[varargin, filtData] = util.argkeyval('filtData',varargin, []); %for speed, if you want to load in processed data instead of running it each time
[varargin, chNum] = util.argkeyval('chNum',varargin, []); %enter the channels
[varargin, filterByTrial] = util.argkeyval('filterByTrial',varargin, true); %if true, will process by breaking the trials up then filters them each time.
[varargin, filterAllData] = util.argkeyval('filterAllData',varargin, false); %if true, will  process by filtering all the data then breaking it up.

if isempty(chNum)
    chNum = 1:size(data, 1);
end

%% set up names for the struct
for ff=1:length(chNum)
    ch = num2str(chNum(ff));
    chName{ff} = ['ch' ch];
end

%% this is breaking the data up by session, then filtering, see below for an alternative DO NOT NEED TO DO BOTH, JUST TROUBLESHOOTING
if filterByTrial 
%     %% pre and post time conversion
%     preTimeC = round(preTime * fs);
%     postTimeC = round(postTime * fs);


    %break up into data epochs centered on image presentation
    %timestamp 2 = first image, and every other is new image until the last one
    itiFiltered = struct;
    idx1 = 1;
%     idxID = 1;
%     idxEmot = 1;
%     idxID1 = 0; idxEmot1 = 0;
%     idxID2 = 0; idxEmot2 = 0;
%     idxID3 = 0; idxEmot3 = 0;
    for ii = 1:size(data,3) %trials
                   for cc = 1:length(chNum) %channels
                %the
                %by image, second group is responese NEED TO CHECK THAT'S WHAT
                %THE SECOND EVENT IS
                % NEED TO REMOVE THE 0S OR FIGURE OUT HOW TO ONLY DO THE
                % INDICES FOR THE TRIAL.

                %image presentation epoch
                [filtDataTemp] =   Analysis.BasicDataProc.dataPrep(data(:, cc, ii), 'needsCombfilter', 0, 'fs', fs, 'MaxFreq', 150); %calls this function for my basic processing stepsdata
                %by identity
                itiFiltered.iti.(chName{cc}).specDzscore(:,:,ii) = filtDataTemp.dataSpec.dataZ;
                itiFiltered.iti.(chName{cc}).specD(:,:,idxID) = filtDataTemp.dataSpec.data;
                %by emotion
                itiFiltered.byemotion.(chName{cc}).image.specDzscore{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = filtDataTemp.dataSpec.dataZ;
                itiFiltered.byemotion.(chName{cc}).image.specD{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = filtDataTemp.dataSpec.data;

                %response epoch

                [filtDataTemp] =   Analysis.BasicDataProc.dataPrep(data(timeStamps(ii+1) - (preTimeC): timeStamps(ii+1) + (postTimeC), cc), 'needsCombfilter', 0, 'fs', fs, 'MaxFreq', 150); %calls this function for my basic processing stepsdata
                %by identity
                itiFiltered.byidentity.(chName{cc}).response.specDzscore{PresentedIdentityIdx(idx1)}(:,:,idxID) = filtDataTemp.dataSpec.dataZ;
                itiFiltered.byidentity.(chName{cc}).response.specD{PresentedIdentityIdx(idx1)}(:,:,idxID) = filtDataTemp.dataSpec.data;
                %by emotion
                itiFiltered.byemotion.(chName{cc}).response.specDzscore{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = filtDataTemp.dataSpec.dataZ;
                itiFiltered.byemotion.(chName{cc}).response.specD{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = filtDataTemp.dataSpec.data;
                %
                %             nback.byidentity.(chName{cc}).response{PresentedIdentityIdx(idx1)}(:,:,idxID) = data(:, timeStamps(ii+1) - (preTime): timeStamps(ii+1) + (postTime), cc);
                %              %by emotion
                %             nback.byemotion.(chName{cc}).image{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = data(:, timeStamps(ii) - (preTime): timeStamps(ii) + (postTime), cc);
                %             nback.byemotion.(chName{cc}).response{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = data(:, timeStamps(ii+1) - (preTime): timeStamps(ii+1) + (postTime), cc);
                %
                %
                %             nback.byidentity.(chName{cc}).response{PresentedIdentityIdx(idx1)}(:,:,idxID) = data(:, timeStamps(ii+1) - (preTime): timeStamps(ii+1) + (postTime), cc);
                %
                %             %by emotion
                %             nback.byemotion.(chName{cc}).image{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = data(:, timeStamps(ii) - (preTime): timeStamps(ii) + (postTime), cc);
                %             nback.byemotion.(chName{cc}).response{PresentedEmotionIdx(idx1)}(:,:,idxEmot) = data(:, timeStamps(ii+1) - (preTime): timeStamps(ii+1) + (postTime), cc);
            end
            idx1 = idx1 + 1;
        end
    end
end





if filterByTrial 
    itiFiltered.time = filtDataTemp.dataSpec.tplot;
    itiFiltered.freq = filtDataTemp.dataSpec.f;
elseif filterAllData 
    nbackFilterAllData.time = filtData.dataSpec.tplot;
    nbackFilterAllData.freq = filtData.dataSpec.f;
end

end




