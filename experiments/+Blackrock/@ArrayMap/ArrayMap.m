classdef ArrayMap < util.Structable
    % ARRAYMAP information about channel layout for Utah electrode arrays
    %
    %   Based on code by Kian Torab (Blackrock Microsystems, Salt Lake
    %   City, UT), ktorab@blackrockmicro.com.
    
    properties
        MapFileHeader = {'// Mapfile generated by Blackrock.ArrayMap (no source file)',...
            '//','//   legend','//   col - 0 based column from left to right',...
            '//   row - 0 based row from bottom to top',...
            '//   bank - bank name - values can be A, B, C, or D',...
            '//   elec - 1 based electrode number within the bank - values can be 1-32',...
            '//   label - label used to rename channels in Central (optional)',...
            '//','// Comments begin with //',...
            '// First non-comment line is the Mapfile description','//',...
            'Cerebus mapping for array Blackrock.ArrayMap Default Values',...
            '//col	row	bank	elec	label'};
        Description = 'Blackrock.ArrayMap Default Values';
        ArrayNum = ... % Array number
            [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1];
        ElecNum = ... % Electrode number
            [96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 ...
            77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 ...
            58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 ...
            39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 ...
            20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1];
        ChanNum = ... % Channel number
            [65 67 69 71 73 75 77 79 2 66 68 70 72 74 76 78 80 81 1 ...
            33 35 37 39 41 45 82 84 83 3 34 36 38 40 43 47 49 86 85 ...
            4 7 5 48 42 44 51 53 87 88 6 9 17 15 50 46 56 55 89 90 ...
            8 11 13 19 54 52 58 57 91 92 10 12 23 25 21 62 60 59 94 ...
            93 14 16 20 27 29 31 64 61 63 96 18 22 24 26 28 30 32 95];
        Column = ... % Column number (0-based from left)
            [0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 ...
            3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 ...
            6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 ...
            8 9 9 9 9 9 9 9 9];
        Row = ... % Row number (0-based from bottom)
            [8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 ...
            9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 ...
            0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 ...
            1 0 8 7 6 5 4 3 2 1];
        Bank = ... % Bank number (1-based)
            [3 3 3 3 3 3 3 3 1 3 3 3 3 3 3 3 3 3 1 2 2 2 2 2 2 3 3 3 1 ...
            2 2 2 2 2 2 2 3 3 1 1 1 2 2 2 2 2 3 3 1 1 1 1 2 2 2 2 3 3 ...
            1 1 1 1 2 2 2 2 3 3 1 1 1 1 1 2 2 2 3 3 1 1 1 1 1 1 2 2 2 ...
            3 1 1 1 1 1 1 1 3];
        Pin = ... % Pin number
            [1 3 5 7 9 11 13 15 2 2 4 6 8 10 12 14 16 17 1 1 3 5 7 9 ...
            13 18 20 19 3 2 4 6 8 11 15 17 22 21 4 7 5 16 10 12 19 21 ...
            23 24 6 9 17 15 18 14 24 23 25 26 8 11 13 19 22 20 26 25 ...
            27 28 10 12 23 25 21 30 28 27 30 29 14 16 20 27 29 31 32 ...
            29 31 32 18 22 24 26 28 30 32 31];
        Label = ... % String label
            {'elec96' 'elec95' 'elec94' 'elec93' 'elec92' 'elec91' ...
            'elec90' 'elec89' 'elec88' 'elec87' 'elec86' 'elec85' ...
            'elec84' 'elec83' 'elec82' 'elec81' 'elec80' 'elec79' ...
            'elec78' 'elec77' 'elec76' 'elec75' 'elec74' 'elec73' ...
            'elec72' 'elec71' 'elec70' 'elec69' 'elec68' 'elec67' ...
            'elec66' 'elec65' 'elec64' 'elec63' 'elec62' 'elec61' ...
            'elec60' 'elec59' 'elec58' 'elec57' 'elec56' 'elec55' ...
            'elec54' 'elec53' 'elec52' 'elec51' 'elec50' 'elec49' ...
            'elec48' 'elec47' 'elec46' 'elec45' 'elec44' 'elec43' ...
            'elec42' 'elec41' 'elec40' 'elec39' 'elec38' 'elec37' ...
            'elec36' 'elec35' 'elec34' 'elec33' 'elec32' 'elec31' ...
            'elec30' 'elec29' 'elec28' 'elec27' 'elec26' 'elec25' ...
            'elec24' 'elec23' 'elec22' 'elec21' 'elec20' 'elec19' ...
            'elec18' 'elec17' 'elec16' 'elec15' 'elec14' 'elec13' ...
            'elec12' 'elec11' 'elec10' 'elec9' 'elec8' 'elec7' ...
            'elec6' 'elec5' 'elec4' 'elec3' 'elec2' 'elec1'};
        LabelPrefix = 'elec'; % Label prefix
        spacing = 0.4; % electrode spacing (millimeters)
        MapFile = nan; % Path to *.cmp file used to construct the object
        verbose = true; % Verbosity (TRUE or FALSE)
        
        idxch2el
        idxel2ch
    end
    
    methods
        function this = ArrayMap(varargin)
            % ARRAYMAP Constructor for Blackrock.ArrayMap object
            %
            %   MAP = ARRAYMAP
            %   Return an ARRAYMAP object with default electrode layout.
            %   Will produce a warning that default values were used.
            %
            %   MAP = ARRAYMAP(MAPFILE)
            %   Provide the path to a *.cmp file in MAPFILE that will be
            %   used to determine the electrode layout.
            
            % override default verbosity
            [varargin,this.verbose] = util.argflag('verbose',varargin,false);
            [varargin,~] = util.argflag('quiet',varargin,false);
            [varargin,this.MapFile] = util.argfn(@(x)ischar(x)&&exist(x,'file')==2&&strcmpi(x(end-(min(length(x),4)-1):end),'.cmp'),varargin,nan);
            
            % read in cmp file if provided
            if isnan(this.MapFile)
                if this.verbose, warning('Using default values for array map information'); end
            else
                
                % read the map file
                fid = fopen(this.MapFile); % open the file
                
                % read the mapfile header, array description
                keepReading = true;
                this.MapFileHeader = {};
                while keepReading
                    
                    % read a line from the file
                    str = strtrim(fgetl(fid));
                    if strcmpi(str(1:2),'//')
                        
                        % save the header string
                        this.MapFileHeader{end+1} = str;
                    else
                        
                        % first non-comment line is the array description
                        this.Description = str(27:end);
                        this.MapFileHeader{end+1} = str;
                        
                        % read the next line, which contains column labels
                        this.MapFileHeader{end+1} = fgetl(fid);
                        
                        % break out of the loop
                        keepReading = false;
                    end
                end
                
                % update first line to indicate custom file
                this.MapFileHeader{1} = '// Mapfile generated by Blackrock.ArrayMap';
                if ~isnan(this.MapFile)
                    this.MapFileHeader{1} = sprintf('%s (source file %s)',this.MapFileHeader{1},this.MapFile);
                else
                    this.MapFileHeader{1} = sprintf('%s (custom values / no source file)',this.MapFileHeader{1});
                end
                
                % read the map data
                filedata = textscan(fid,'%d %d %s %d %s'); % read info
                fclose(fid); % close the file
                
                % pull out col, row, bank, pin, label, and calculate chan num
                this.Column = double(filedata{:,1});
                this.Row = double(filedata{:,2});
                this.Bank = cellfun(@(x)x-'@',filedata{:,3});
                this.Pin = double(filedata{:,4});
                this.Label = filedata{:,5};
                this.ChanNum = (this.Bank - 1)*32 + this.Pin;
            end
            
            % user overrides
            [varargin,this.Column] = util.argkeyval('column',varargin,this.Column);
            [varargin,this.Row] = util.argkeyval('row',varargin,this.Row);
            [varargin,this.Bank] = util.argkeyval('bank',varargin,this.Bank);
            [varargin,this.Pin] = util.argkeyval('pin',varargin,this.Pin);
            [varargin,this.Label] = util.argkeyval('label',varargin,this.Label);
            [varargin,this.ChanNum] = util.argkeyval('channum',varargin,this.ChanNum);
            [varargin,this.ElecNum] = util.argkeyval('elecnum',varargin,this.ElecNum);
            
            % make sure no leftover inputs
            util.argempty(varargin);
            
            % determine label prefix, pull out electrode and array numbers
            if all(cellfun(@(x)ismember('-',x),this.Label))
                LabelTokens = regexp(this.Label,'(?<prefix>[^\d]+)(?<arraynum>\d+)-(?<elecnum>\d+)','names');
            elseif ~any(cellfun(@(x)ismember('-',x),this.Label))
                LabelTokens = regexp(this.Label,'(?<prefix>[^\d]+)(?<elecnum>\d+)','names');
            else
                error('Unknown label structure, please manually check and revise.');
            end
            LabelTokens = cat(1,LabelTokens{:});
            assert( isstruct(LabelTokens) && isfield(LabelTokens,'prefix') && isfield(LabelTokens,'elecnum'),'Could not identify label prefix');
            this.LabelPrefix = unique({LabelTokens.prefix});
            elecnums = cellfun(@str2double,{LabelTokens.elecnum});
            this.ElecNum = elecnums(:);
            if isfield(LabelTokens,'arraynum')
                arraynums = cellfun(@str2double,{LabelTokens.arraynum});
                this.ArrayNum = arraynums(:);
            end
            
            % create indices for converting between channel and electrode
            this.idxch2el = nan(1,length(this.ChanNum));
            for kk=1:length(this.ChanNum)
                this.idxch2el(this.ChanNum(kk)) = this.ElecNum(kk);
            end
            this.idxel2ch = nan(1,length(this.ElecNum));
            for kk=1:length(this.ElecNum)
                this.idxel2ch(this.ElecNum(kk)) = this.ChanNum(kk);
            end
            
        end % END function ArrayMap
        
        function Channel = el2ch(this,Electrode)
            % EL2CH Convert electrode number into channel
            %
            %   CH = EL2CH(THIS,EL)
            %   Get the channel corresponding to elecrode EL.
            idx_good = ismember(Electrode,this.ElecNum);
            Channel = nan(1,length(Electrode));
            Channel(idx_good) = this.idxel2ch(Electrode(idx_good));
            
            % Channel = zeros(size(Electrode));
            % for idx = 1:length(Electrode)
            %     Channel(idx) = this.ChanNum(this.ElecNum == Electrode(idx));
            %     assert(Channel(idx)==this.idxel2ch(Electrode(idx)));
            % end
        end % END function el2ch
        
        function Electrode = ch2el(this,Channel)
            % CH2EL Convert channel number into electrode
            %
            %   EL = CH2EL(THIS,CH)
            %   Get the electrode corresponding to channel CH.
            idx_good = ismember(Channel,this.ChanNum);
            Electrode = nan(1,length(Channel));
            Electrode(idx_good) = this.idxch2el(Channel(idx_good));
            
            % Electrode = nan(size(Channel));
            % for idx = 1:length(Channel)
            %     chIdx = find(this.ChanNum == Channel(idx));
            %     if ~isempty(chIdx)
            %         Electrode(idx) = this.ElecNum(chIdx);
            %         assert(Electrode(idx)==this.idxch2el(Channel(idx)));
            %     end
            % end
        end % END function ch2el
        
        function ArrayNum = ch2arr(this,Channel)
            % CH2ARR Convert channel number into array number
            %
            %   ARR = CH2ARR(THIS,CH)
            %   Get the array number corresponding to channel CH.
            
            ArrayNum = zeros(size(Channel));
            for idx = 1:length(Channel)
                ArrayNum(idx) = this.ArrayNum(this.ChanNum == Channel(idx));
            end
        end % END function ch2arr
        
        function ArrayNum = el2arr(this,Electrode)
            % EL2ARR Convert electrode number into array number
            %
            %   ARR = EL2ARR(THIS,EL)
            %   Get the array number corresponding to electrode EL.
            
            ArrayNum = zeros(size(Electrode));
            for idx = 1:length(Electrode)
                ArrayNum(idx) = this.ArrayNum(this.ElecNum == Electrode(idx));
            end
        end % END function el2arr
        
        function Bank = ch2b(this,Channel)
            % CH2B Convert channel number into bank
            %
            %   B = CH2B(THIS,CH)
            %   Get the bank corresponding to channel CH.
            
            Bank = zeros(size(Channel));
            for idx = 1:length(Channel)
                Bank(idx) = this.Bank(this.ChanNum == Channel(idx));
            end
        end % END function ch2b
        
        function Bank = el2b(this,Electrode)
            % EL2B Convert electrode number into bank
            %
            %   B = EL2B(THIS,EL)
            %   Get the bank corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            Bank = ch2b(this,ch);
        end % END function el2b
        
        function Label = ch2lbl(this,Channel)
            % CH2LBL Convert channel number into label
            %
            %   LBL = CH2LBL(THIS,CH)
            %   Get the label corresponding to channel CH.
            
            Label = char(this.Label{this.ChanNum == Channel});
        end % END function ch2lbl
        
        function Label = el2lbl(this,Electrode)
            % EL2LBL Convert electrode number into label
            %
            %   LBL = EL2LBL(THIS,EL)
            %   Get the label corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            Label = ch2lbl(this,ch);
        end % END function el2lbl
        
        function Pin = ch2p(obj, Channel)
            % CH2P Convert channel number into pin number
            %
            %   P = CH2P(THIS,CH)
            %   Get the pin corresponding to channel CH.
            
            Pin = zeros(size(Channel));
            for idx = 1:length(Channel)
                Pin(idx) = obj.Pin(obj.ChanNum == Channel(idx));
            end
        end % END function ch2p
        
        function Pin = el2p(this,Electrode)
            % EL2P Convert electrode number into pin
            %
            %   P = EL2P(THIS,EL)
            %   Get the pin corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            Pin = ch2p(this,ch);
        end % END function el2p
        
        function col = ch2col(this,Channel)
            % CH2COL Convert channel number into column number
            %
            %   COL = CH2COL(THIS,CH)
            %   Get the column corresponding to channel CH.
            
            col = zeros(size(Channel));
            for idx = 1:length(Channel)
                col(idx) = this.Column(this.ChanNum == Channel(idx));
            end
        end % END function ch2col
        
        function col = el2col(this,Electrode)
            % EL2COL Convert electrode number into column number
            %
            %   COL = EL2COL(THIS,EL)
            %   Get the column corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            col = ch2col(this,ch);
        end % END function el2col
        
        function row = ch2row(this,Channel)
            % CH2ROW Convert channel number into row number
            %
            %   ROW = CH2ROW(THIS,CH)
            %   Get the row corresponding to channel CH.
            
            row = zeros(size(Channel));
            for idx = 1:length(Channel)
                row(idx) = this.Row(this.ChanNum == Channel(idx));
            end
        end % END function ch2row
        
        function row = el2row(this,Electrode)
            % EL2ROW Convert electrode number into row number
            %
            %   ROW = EL2ROW(THIS,EL)
            %   Get the row corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            row = ch2row(this,ch);
        end % END function el2col
        
        function [col,row] = ch2cr(this,Channel)
            % CH2CR Convert channel number into column and row values
            %
            %   [COL,ROW] = CH2CR(THIS,CH)
            %   Get the column and row corresponding to channel CH.
            
            col = ch2col(this,Channel);
            row = ch2row(this,Channel);
        end % END function ch2cr
        
        function [col,row] = el2cr(this,Electrode)
            % EL2CR Convert electrode number into column and row values
            %
            %   [COL,ROW] = EL2CR(THIS,EL)
            %   Get the column and row corresponding to electrode EL.
            
            ch = el2ch(this,Electrode);
            [col,row] = ch2cr(this,ch);
        end % END function el2cr
        
        function ch = cr2ch(this,col,row)
            % CR2CH Convert column and row values into a channel number
            %
            %   CH = CR2CH(THIS,COL,ROW)
            %   Get the channel corresponding to column COL and row ROW.
            
            ch = nan(size(col));
            for idx = 1:length(col)
                chan = this.ChanNum( this.Column==col(idx) & this.Row==row(idx) );
                if(~isempty(chan))
                    ch(idx) = chan;
                end
            end
        end % END function cr2ch
        
        function el = cr2el(this,col,row)
            % CR2EL Convert column and row values into an electrode number
            %
            %   EL = CR2EL(THIS,COL,ROW)
            %   Get the electrode corresponding to column COL and row ROW.
            
            ch = cr2ch(this,col,row);
            el = ch2el(this,ch);
        end % END function cr2el
        
        function [x,y] = cr2xy(this,c,r)
            % CR2XY Convert column and row values to 1-based indexing
            %
            %   [X,Y] = CR2XY(THIS,C,R)
            %   Convert array positions specified by columns (C) and rows
            %   (R) into array or subplot positions identified by their
            %   x-position (X) and y-position (Y). In effect, this
            %   translates column and row indexing (which may or may not
            %   start at 1) into a 1-based vector. Note that the y-position
            %   remains vertically flipped from the MATLAB array indexing
            %   paradigm, but is correctly oriented for MATLAB subplot
            %   indexing.
            
            % list all possible array columns and rows
            arrcol = min(this.Column):max(this.Column);
            arrrow = min(this.Row):max(this.Row);
            
            % validate inputs
            assert(all(ismember(c,arrcol)),'Could not find some columns in the list of array columns');
            assert(all(ismember(r,arrrow)),'Could not find some rows in the list of array rows');
            assert(length(c)==length(r),'Must provide same number of columns and rows');
            
            % convert array column and row into 1-based x/y indices
            x = nan(1,length(c));
            y = nan(1,length(c));
            for ii=1:length(c)
                x(ii) = find(arrcol==c(ii));
                y(ii) = find(arrrow==r(ii));
            end
        end % END function cr2xy
        
        function ch = bp2ch(this,bank,pin)
            % BP2CH Convert bank and pin values into a channel number
            %
            %   CH = BP2CH(THIS,B,P)
            %   Get the channel corresponding to bank B and pin P.
            
            if ischar(bank)
                bank = double(bank-'@'); % convert to 1-indexed bank number
            end
            ch = zeros(size(bank));
            for idx = 1:length(bank)
                ch(idx) = this.ChanNum( this.Bank==bank(idx) & this.Pin==pin(idx) );
            end
        end % END function bp2ch
        
        function el = bp2el(this,bank,pin)
            % BP2EL Convert bank and pin values into electrode number
            %
            %   EL = BP2EL(THIS,B,P)
            %   Get the electrode corresponding to bank B and pin P.
            
            ch = bp2ch(this,bank,pin);
            el = ch2el(this,ch);
        end % END function bp2el
        
        function [c,r] = xy2cr(this,x,y)
            % XY2CR Convert 1-based x/y indices to array column/row
            %
            %   [C,R] = XY2CR(THIS,X,Y)
            %   Convert 1-based column and row indices X and Y into array
            %   columns (C) and rows (R). In effect, this translates
            %   1-based indexing (suitable for matrices or subplots) into
            %   array-based indexing (which may or may not start at 1).
            
            % list all possible array columns and rows
            arrcol = min(this.Column):max(this.Column);
            arrrow = min(this.Row):max(this.Row);
            
            % validate input
            assert(all(x<=max(arrcol))&&all(x>=min(arrcol)),'x inputs must fall in the range [%d,%d]',min(arrcol),max(arrcol));
            assert(all(y<=max(arrrow))&&all(y>=min(arrrow)),'y inputs must fall in the range [%d,%d]',min(arrrow),max(arrrow));
            
            % convert 1-based x/y indices into array column and row
            c = arrcol(x);
            r = arrrow(y);
        end % END function xy2cr
        
        function pos = xy2pos(this,x,y,innerspacing,range_height,range_width)
            % XY2POS Convert plot col/row to [l b w h] position vector
            %
            %   POS = XY2POS(THIS,X,Y)
            %   Convert 1-based x/y indices into subplot positions. Inputs
            %   X and Y are contiguous from one to the maximum number of
            %   columns and rows, respectively, and represent the 1-based
            %   relative position of the channel within the set of all
            %   possible channel positions. The output POS is directly
            %   usable with MATLAB graphics routines, i.e., to set a
            %   subplot position, and comprise the left starting pixel,
            %   bottom starting pixel, width in pixels, and height in
            %   pixels as [l b w h].
            if nargin<4||isempty(innerspacing),innerspacing=0.004;end
            if nargin<5||isempty(range_height),range_height=[0 1];end
            if nargin<6||isempty(range_width),range_width=[0 1];end
            
            % calculate the range of normalized positions in the axes
            availw = diff(range_width);
            availh = diff(range_height);
            
            % calculate the number of columns and rows
            numcol = max(this.Column) - min(this.Column) + 1;
            numrow = max(this.Row) - min(this.Row) + 1;
            
            % validate inputs
            assert(length(x)==length(y),'Must provide same number of columns and rows');
            
            % calculate the position of each x/y pair
            % position is a normalized interpolation into the calculated
            % range, e.g., START+(IDX*RANGE/NUM), and accounts for having
            % some spacing between subplots.
            pos = nan(length(x),4);
            for ii=1:length(x)
                left = range_width(1)+(x(ii)-1)*(availw/numcol+innerspacing);
                bottom = range_height(1)+(y(ii)-1)*(availh/numrow+innerspacing);
                width = (availw/numcol)-innerspacing;
                height = (availh/numrow)-innerspacing;
                pos(ii,:) = [left bottom width height];
            end
        end % END function xy2pos
        
        function h = getEmptySubplots(this,varargin)
            % GETEMPTYSUBPLOTS get handles to empty array locations
            %
            %   H = GETEMPTYSUBPLOTS(THIS)
            %   Get a vector of handles to the subplots corresponding to
            %   empty array locations.
            %
            %   GETEMPTYSUBPLOTS(...,'INNERSPACING',VAL)
            %   Specify the normalized spacing between subplot axes
            %   (default 0.004).
            %
            %   GETEMPTYSUBPLOTS(...,SUBPLOT_ARGS)
            %   Provide a list of arguments as a cell array SUBPLOT_ARGS to
            %   be passed on to the SUBPLOT function.
            
            [varargin,innerspacing] = util.argkeyval('InnerSpacing',varargin,0.004);
            [varargin,outerspacing] = util.argkeyval('OuterSpacing',varargin,0);
            [varargin,colorbarspace] = util.argkeyval('ColorbarSpace',varargin,0);
            [varargin,titlespace] = util.argkeyval('TitleSpace',varargin,0);
            
            % get list of used col/row pairs
            [colused,rowused] = ch2cr(this,1:96);
            [xused,yused] = cr2xy(this,colused,rowused);
            allused = [xused(:) yused(:)];
            
            % calculate list of all possible col/row pairs
            numrow = max(this.Row)-min(this.Row)+1;
            numcol = max(this.Column)-min(this.Column)+1;
            [xpossible,ypossible] = ndgrid(1:numcol,1:numrow);
            allpossible = [xpossible(:) ypossible(:);];
            
            % find which possibilities aren't being used
            allempty = setdiff(allpossible,allused,'rows');
            numempty = size(allempty,1);
            
            % create subplots for unused col/row pairs
            range_height = [outerspacing 1-outerspacing-titlespace];
            range_width = [outerspacing 1-outerspacing-colorbarspace];
            h = zeros(1,numempty);
            for hIdx = 1:length(h)
                pos = xy2pos(this,allempty(hIdx,1),allempty(hIdx,2),innerspacing,range_height,range_width);
                h(hIdx) = getAxes(this,pos,nan,varargin{:});
            end
            % axis(h,'off');
        end % END function getEmptySubplots
        
        function h = getElectrodeSubplot(this,Electrode,varargin)
            % GETELECTRODESUBPLOT get a subplot handle for an electrode
            %
            %   H = GETELECTRODESUBPLOT(THIS,ELECTRODE)
            %   Get a handle or handles for the subplots corresponding to
            %   array location of the electrode or electrodes specified in 
            %   ELECTRODE.
            %
            %   GETELECTRODESUBPLOT(...,SUBPLOT_ARGS)
            %   Provide a list of arguments as a cell array SUBPLOT_ARGS to
            %   be passed on to the SUBPLOT function.
            
            h = getChannelSubplot(this,this.el2ch(Electrode),varargin{:});
        end % END function getElectrodeSubplot
        
        function h = getChannelSubplot(this,Channel,varargin)
            % GETCHANNELSUBPLOT get a subplot handle for a channel
            %
            %   H = GETCHANNELSUBPLOT(THIS,CHANNEL)
            %   Get a handle or handles for the subplots corresponding to
            %   array location of the channel or channels specified in 
            %   CHANNEL.
            %
            %   GETCHANNELSUBPLOT(...,'INNERSPACING',VAL)
            %   Specify the normalized spacing between subplot axes
            %   (default 0.004).
            %
            %   GETCHANNELSUBPLOT(...,'OUTERSPACING',VAL)
            %   Specify the normalized spacing around the edges of the
            %   array (default 0).
            %
            %   GETCHANNELSUBPLOT(...,'COLORBARSPACE',VAL)
            %   Specify the width of a vertical strip to be preserved on
            %   the righthand side of the plot, presumably for a colorbar.
            %
            %   GETCHANNELSUBPLOT(...,'TITLESPACE',VAL)
            %   Specify the height of a horizontal strip to be preserved on
            %   the top of the plot, presumably for a title.
            %
            %   GETCHANNELSUBPLOT(...,SUBPLOT_ARGS)
            %   Provide a list of arguments as a cell array SUBPLOT_ARGS to
            %   be passed on to the SUBPLOT function.
            
            [varargin,innerspacing] = util.argkeyval('InnerSpacing',varargin,0.004);
            [varargin,outerspacing] = util.argkeyval('OuterSpacing',varargin,0);
            [varargin,colorbarspace] = util.argkeyval('ColorbarSpace',varargin,0);
            [varargin,titlespace] = util.argkeyval('TitleSpace',varargin,0);
            
            h = zeros(size(Channel));
            [c,r] = ch2cr(this,Channel);
            [x,y] = cr2xy(this,c,r);
            range_height = [outerspacing 1-outerspacing-titlespace];
            range_width = [outerspacing 1-outerspacing-colorbarspace];
            for idx = 1:length(Channel)
                pos = xy2pos(this,x(idx),y(idx),innerspacing,range_width,range_height);
                h(idx) = getAxes(this,pos,Channel(idx),varargin{:});
            end
        end % END function getChannelSubplot
        
        function h = getAxes(this,pos,ch,varargin)
            % GETAXES Convenience function to get axes handles
            [varargin,xtick] = util.argkeyval('XTick',varargin,[]);
            [varargin,ytick] = util.argkeyval('YTick',varargin,[]);
            [varargin,xticklbl] = util.argkeyval('XTickLabel',varargin,[]);
            [varargin,yticklbl] = util.argkeyval('YTickLabel',varargin,[]);
            [varargin,clr] = util.argkeyval('Color',varargin,[0.5 0.5 0.5]);
            [varargin,xgrid] = util.argkeyval('XGrid',varargin,'off');
            [varargin,ygrid] = util.argkeyval('YGrid',varargin,'off');
            [varargin,boxonoff] = util.argkeyval('Box',varargin,'on');
            
            % construct list of all arguments for axes function
            axargs = [varargin {'Box',boxonoff,...
                'XTick',xtick,'XTickLabel',xticklbl,...
                'YTick',ytick,'YTickLabel',yticklbl,...
                'XGrid',xgrid,'YGrid',ygrid,...
                'Color',clr}];
            
            % validate inputs
            assert(size(pos,1)==length(ch),'Must provide the same number of positions as channels');
            assert(all(ismember(ch(~isnan(ch)),this.ChanNum)),'All non-NaN channels must be present in the list of channel numbers');
            
            % create axes handles
            h = [];
            for ii=length(ch):-1:1 % to pre-allocate h on first iteration
                if isnan(ch(ii))
                    chargs = axargs;
                else
                    chargs = [axargs {'tag',sprintf('axesChannel%2d',ch(ii)),'UserData',struct('Channel',ch(ii))}];
                end
                h(ii) = axes('position',pos,chargs{:});
            end
        end % END function getAxes
        
        function varargout = plot(this,varargin)
            % PLOT Visual representation of the array layout
            %
            %   PLOT(THIS)
            %   Generate a plot which shows the channel number for each 
            %   location in the array.
            %
            %   PLOT(...,VALUES)
            %   Generate a plot which shows the values in VALUES on the 
            %   array. VALUES must be a vector of length 96.  By default, 
            %   VALUES is the vector 1:96.  The index of each value is 
            %   interpreted as its channel number in order to determine 
            %   array location.
            %
            %   PLOT(...,NAME)
            %   Provide a string in NAME to identify the values being
            %   displayed.  NAME will be interpreted as the label of the
            %   text values.
            %
            %   PLOT(...,'BACKGROUND')
            %   Use VALUES as color data for the background color of each 
            %   subplot.  TEXTNAME will be copied to the BACKGROUNDNAME 
            %   property.
            %
            %   PLOT(...,'FOREGROUND')
            %   Use VALUES as color data for the text.
            %
            %   PLOT(...,'NOTEXT')
            %   Do not display VALUES as text on each array location.
            %
            %   PLOT(...,'COLORBAR')
            %   Display a colorbar on the right side of the plot.  The
            %   colorbar label will be the BACKGROUNDNAME property.  The
            %   colorbar limits will be defined by BACKGROUNDCOLORLIMS.
            %
            %   PLOT(...,'FIGURENAME',NAME)
            %   Provide a string in NAME for the name of the figure.  The
            %   default figure name will be automatically constructed using
            %   the background and text names.
            %
            %   PLOT(...,'FORMAT',STR)
            %   Use the sprintf-style format in STR to convert VALUES to
            %   strings.
            %
            %   PLOT(...,'FONTSIZE',SIZE)
            %   Use a custom font size (in points) specified by SIZE.  By
            %   default, SIZE is 24 points.
            %
            %   PLOT(...,'TEXTCOLOR',COLOR)
            %   PLOT(...,'BACKGROUNDCOLOR',COLOR)
            %   Specify color of the text and subplot backgrounds.  COLOR 
            %   may be a single RGB triplet, a 96x3 array with one RGB 
            %   triplet per channel, or one scalar per channel.  If COLOR 
            %   is a single RGB triplet, all channels will be the same 
            %   color.  If COLOR is a 96x3 array, channel N will assume the
            %   color defined in row N of COLOR.  If COLOR is a vector of 
            %   length 96, the Nth value of COLOR will be used as an index
            %   into BACKGROUNDCOLORMAP or TEXTCOLORMAP.  The default
            %   background color is white and the default text color is
            %   black.
            %
            %   PLOT(...,'TEXTCOLORMAP',COLORMAP)
            %   PLOT(...,'BACKGROUNDCOLORMAP',COLORMAP)
            %   Provide a colormap in COLORMAP from which to sample colors
            %   for the text or background.  In the case of text, COLORMAP
            %   is used to index RGB triplets directly.  In the case of
            %   background, COLORMAP becomes the figure's colormap.  By 
            %   default, the background colormap is all white and the text
            %   colormap is all black.
            %
            %   PLOT(...,'TEXTCOLORLIMS',LIMS)
            %   PLOT(...,'BACKGROUNDCOLORLIMS',LIMS)
            %   Specify the color limits in LIMS.  If unspecified, the 
            %   limits will be either [0,1] (if all colors specified fall 
            %   within that range) or [min,max] of the background colors.
            %
            %   PLOT(...,'EMPTYCOLOR',COLOR)
            %   Provide a single RGB triplet that will serve as the color
            %   of the empty array positions.  By default, the empty color
            %   is [0.5 0.5 0.5]. NOT WORKING.
            %
            %   PLOT(...,'BUTTONDOWNFCN',FCN)
            %   Provide a button-down callback function which will be
            %   assigned to the axes for each array location, to the
            %   image object used for the colored backgrounds, and to the
            %   text object used to display VALUES.  Additionally, each of
            %   these objects will have UserData set to a struct with a
            %   single field 'Channel' which has the channel number for
            %   that array location.
            %
            %   [H1,H2] = PLOT(...)
            %   Return a handle to the channel subplots in H1 and the empty
            %   locations in H2.
            %
            %   Examples:
            %
            %     % construct map object
            %     map = Blackrock.ArrayMap;
            %
            %     % plot channels in black text against a white background.
            %     map.plot
            %
            %     % use channel numbers as background color data
            %     map.plot('background')
            %
            %     % use color only (no text) and display a colorbar
            %     map.plot('background','notext','colorbar')
            %
            %     % text from channels, color from banks, new colormap
            %     map.plot(...
            %       'BackgroundName','Banks',...
            %       'BackgroundColor',map.ch2b(1:96),...
            %       'BackgroundColorMap','parula',...
            %       'colorbar');
            %
            %     % floating point values with correlated background color
            %     map.plot(...
            %       'Floating Point Data',...
            %       0.5*rand([1 96]),...
            %       'background',...
            %       'colorbar',...
            %       'Format','%.2f,...
            %       'FontSize',12,...
            %       'BackgroundColorLims',[0 0.5]);
            %
            %     % print electrode number when clicking on a channel
            %     map.plot('Background','ButtonDownFcn',...
            %       @(h,~)fprintf('%d\n',map.ch2el(h.UserData.Channel)));
            
            % default values
            defaultColorMap = 'bone';
            defaultBackgroundColor = [1 1 1];
            defaultTextColor = [0 0 0];
            defaultEmptyColor = [0.5 0.5 0.5];
            defaultFigureName = '';
            defaultButtonDownFcn = @(h,evt)h;
            defaultInnerSpacing = 0;
            defaultOuterSpacing = 0.02;
            
            % create the figure early for colormap
            [varargin,fig,~,found] = Utilities.argkeyval('hFigure',varargin,[]);
            if ~found
                fig = figure(...
                    'NumberTitle','off',...
                    'color',[1 1 1]);
            end
            
            % color of the empty corner plots
            [varargin,EmptyColor] = util.argkeyval('EmptyColor',varargin,defaultEmptyColor);
            
            % callback function when clicking on the subplot
            [varargin,ButtonDownFcn] = util.argkeyval('ButtonDownFcn',varargin,defaultButtonDownFcn);
            
            % display a colorbar on the right side of the plot
            [varargin,ShowColorbar] = util.argflag('colorbar',varargin,false);
            
            % formatting string (for sprintf) to convert values to strings
            [varargin,Format] = util.argkeyval('Format',varargin,'%d');
            
            % use values as color data for background, foreground (text), or nothing
            [varargin,UseValuesAsColorIn] = util.argkeyword({'background','foreground','none'},varargin,'none');
            
            % display the values as text or hide them
            [varargin,ShowText] = util.argkeyword({'text','notext'},varargin,'text');
            
            % size of the printed text
            [varargin,FontSize] = util.argkeyval('FontSize',varargin,20);
            
            % parameters for text color
            [varargin,TextColorMap] = util.argkeyval('TextColorMap',varargin,defaultColorMap);
            [varargin,TextColorLims] = util.argkeyval('TextColorLims',varargin,[]);
            [varargin,TextColor] = util.argkeyval('TextColor',varargin,[]);
            
            % parameters for background color
            [varargin,BackgroundColorMap] = util.argkeyval('BackgroundColorMap',varargin,defaultColorMap);
            [varargin,BackgroundColorLims] = util.argkeyval('BackgroundColorLims',varargin,[]);
            [varargin,BackgroundColor] = util.argkeyval('BackgroundColor',varargin,[]);
            
            % spacing parameters
            [varargin,InnerSpacing] = util.argkeyval('InnerSpacing',varargin,defaultInnerSpacing);
            [varargin,OuterSpacing] = util.argkeyval('OuterSpacing',varargin,defaultOuterSpacing);
            
            % values to be displayed
            [varargin,Values] = util.argfn(@(x)isnumeric(x)&&length(x)>3,varargin,1:96);
            
            % configure text color
            [TextColor,TextColorMap,~] = processColor(Values,strcmpi(UseValuesAsColorIn,'foreground'),defaultTextColor,TextColor,TextColorMap,TextColorLims);
            [BackgroundColor,BackgroundColorMap,BackgroundColorLims] = processColor(Values,strcmpi(UseValuesAsColorIn,'background'),defaultBackgroundColor,BackgroundColor,BackgroundColorMap,BackgroundColorLims);
            
            % default or customized text / background names
            if length(varargin)<=1 % empty or single overriding
                
                % default or extra input
                Name = 'Channels';
                if ~isempty(varargin)
                    Name = varargin{1};
                    varargin(1) = [];
                end
                
                % assign textname if text will be shown
                if ShowText
                    TextName = Name;
                end
                
                % assign backgroundname if colorbar (for colorbar label),
                % or no text shown and background color represents values
                BackgroundName = '';
                if ShowColorbar || (~ShowText && strcmpi(UseValuesAsColorIn,'background'))
                    BackgroundName = Name;
                end
            else
                
                % user-specified custom values
                [varargin,TextName] = util.argkeyval('TextName',varargin,'');
                if isempty(varargin) && strcmpi(UseValuesAsColorIn,'background')
                    BackgroundName = TextName;
                else
                    [varargin,BackgroundName] = util.argkeyval('BackgroundName',varargin,'');
                end
            end
            
            % default figure name and user input
            name = defaultFigureName;
            if ShowText && ~isempty(TextName)
                name = sprintf('%s%s',name,TextName);
            elseif ~ShowText && strcmpi(UseValuesAsColorIn,'background')
                name = sprintf('%s%s',name,BackgroundName);
            end
            if ~ShowColorbar && ~isempty(BackgroundName)
                name = sprintf('%s / %s',name,BackgroundName);
            end
            [varargin,FigureName] = util.argkeyval('FigureName',varargin,name);
            
            % make sure nothing unprocessed
            util.argempty(varargin);
            
            % update figure
            set(fig,'Name',FigureName);
            colormap(fig,BackgroundColorMap);
            
            % identify electrode positions
            cbsp = 0;
            if ShowColorbar, cbsp = 0.1; end
            h1 = getChannelSubplot(this,1:96,'innerspacing',InnerSpacing,...
                'outerspacing',OuterSpacing,'colorbarspace',cbsp,...
                'color',[1 1 1],'ButtonDownFcn',ButtonDownFcn);
            for Channel = 1:96
                image(BackgroundColor(Channel)*ones(10,10),'Parent',h1(Channel),'ButtonDownFcn',ButtonDownFcn,'UserData',struct('Channel',Channel));
                if ShowText
                    str = sprintf(Format,Values(Channel));
                    text(9,5,str,'Color',TextColorMap(round(TextColor(Channel)),:),...
                        'FontSize',FontSize,'parent',h1(Channel),...
                        'HorizontalAlignment','right',...
                        'ButtonDownFcn',ButtonDownFcn,...
                        'UserData',struct('Channel',Channel));
                    set(h1(Channel),'XTick',[],'YTick',[]);
                end
            end
            
            % identify disconnected elements
            h2 = getEmptySubplots(this,'innerspacing',InnerSpacing,...
                'outerspacing',OuterSpacing,'colorbarspace',cbsp,...
                'Color',EmptyColor,'XTick',[],'YTick',[],'box','off');
            
            % colorbar
            if ShowColorbar
                h3 = subplot('Position',[0.9 0.02 0.05 0.96]);
                imagesc((1:size(BackgroundColorMap,1))','Parent',h3,[1 size(BackgroundColorMap,1)]); axis xy;
                set(h3,'YAxisLocation','right');
                hLabel = ylabel(BackgroundName);
                set(hLabel,'Rotation',270);
                set(h3,'TickLength',[0 0],'XTick',[],'YTick',[1 size(BackgroundColorMap,1)],'YTickLabel',{num2str(BackgroundColorLims(1)),num2str(BackgroundColorLims(2))});
                pos = get(hLabel,'Position');
                set(hLabel,'Position',[2.2 pos(2:3)]);
            end
            
            if nargout>0, varargout{1} = fig; end
            if nargout>1
                if ShowColorbar
                    varargout{2} = [h1 h2 h3];
                else
                    varargout{2} = [h1 h2];
                end
            end
            
            function [Color,Map,Lims] = processColor(Values,ValueUse,DefaultColor,Color,Map,Lims)
                % PROCESSCOLOR Configure color, colormap, and colorlims
                %
                %   [COLOR,MAP,LIMS] = PROCESSCOLOR(VALUES,VALUEUSE,...
                %       DEFAULTCOLOR,COLOR,MAP,LIMS)
                %   Process inputs and defaults to generate the correct 
                %   colors, colormap, and colorlims.  This nested function
                %   exists for convenience since both the text and
                %   background colors must be processed identically.
                
                % adopting values for color data
                if ValueUse
                    Color = Values;
                elseif isempty(Color)
                    Color = DefaultColor;
                end
                
                % make sure color data is numeric
                assert(isnumeric(Color),'Color must be numeric');
                
                % color is either RGB triplets or linear indices
                if any(size(Color)==3)
                    
                    % correct orientation
                    if size(Color,1)==3, Color=Color'; end
                    
                    % single triplet: repmat up to full 96x3
                    if size(Color,1)==1
                        Color = repmat(Color,96,1);
                    end
                    
                    % create colormap, color, and colorlims
                    Map = Color;
                    Color = 1:96;
                    Lims = [1 96];
                elseif length(Color(:))==96
                    
                    % ensure row vector
                    Color = Color(:)';
                    
                    % convert colormapp
                    if ischar(Map), Map=colormap(fig,Map); end
                    
                    % calculate color limits
                    if isempty(Lims)
                        if all(Color<=1)
                            Lims = [0 1];
                        else
                            Lims = util.minmax(Color);
                        end
                    end
                else
                    error('Invalid text color specification');
                end
                
                % transform Color into the colormap space
                Color = (Color-Lims(1)) / diff(Lims); % normalize to [0,1]
                Color = Color*(size(Map,1)-1)+1; % rescale to [1,size(BackgroundColorMap,1)]
            end % END function processColor
        end % END function plot
        
        function lt = ch2layout(this,vec,varargin)
            % CH2LAYOUT convert a vector to a matrix by channel position
            %
            %   LT = CH2LAYOUT(THIS,VEC)
            %   Create a matrix LT where the Nth element of VEC is placed
            %   at the array location of channel N.
            %
            %   CH2LAYOUT(...,'INTERP[OLATE]')
            %   CH2LAYOUT(...,'NOINTE[RPOLATE]')
            %   Interpolate the values for the empty locations, or assign 
            %   NaN (default).
            
            lt = this.vec2layout(vec,'channel',varargin{:});
        end % END function ch2layout
        
        function lt = el2layout(this,vec,varargin)
            % EL2LAYOUT convert a vector to a matrix by electrode position
            %
            %   LT = EL2LAYOUT(THIS,VEC)
            %   Create a matrix LT where the Nth element of VEC is placed
            %   at the array location of electrode N.
            %
            %   EL2LAYOUT(...,'INTERP[OLATE]')
            %   EL2LAYOUT(...,'NOINTE[RPOLATE]')
            %   Interpolate the values for the empty locations, or assign 
            %   NaN (default).
            
            lt = this.vec2layout(vec,'electrode',varargin{:});
        end % END function el2layout
        
        function lt = layout(this,which)
            % LAYOUT Return matrix of array layout
            %
            %   LT = LAYOUT(THIS)
            %   Return the layout of array channel numbers
            %
            %   LT = LAYOUT(...,'EL[ECTRODES]')
            %   LT = LAYOUT(...,'CH[ANNELS]')
            %   Specify either electrode or channel layout
            
            % handle input and defaults
            if nargin<2,which='channels';end
            lt = vec2layout(this,sort(this.ChanNum,'ascend'),which);
        end % END function layout
        
        function lt = vec2layout(this,vec,varargin)
            % VEC2LAYOUT convert a vector to a matrix
            %
            %   LT = VEC2LAYOUT(THIS,VEC)
            %   Create a matrix LT where the Nth element of VEC is placed
            %   at the array location of channel N.
            %
            %   VEC2LAYOUT(...,'CHANNEL')
            %   VEC2LAYOUT(...,'ELECTRODE')
            %   Use array location of channels (default) or electrodes.
            %
            %   VEC2LAYOUT(...,'NUM',NUMBERS)
            %   Default behavior expects values in VEC to be provided in
            %   ascending channel (default) or electrode (see above) order.
            %   If the data in vec is ordered differently, provide the
            %   order in NUMBERS.
            %
            %   VEC2LAYOUT(...,'INTERP')
            %   Interpolate the values for the empty locations (default
            %   behavior will assign NaN.
            
            % check correct vector input
            assert( min(size(vec))==1 || max(size(vec))==length(this.ChanNum),'Must provide a %d-element vector input (one value per channel)',length(this.ChanNum));
            
            % process user input
            [varargin,mode] = util.argkeyword({'channel','electrode'},varargin,'channel',2);
            
            % assume the input data are provided in ascending order of the
            % requested mode (ascending channels or ascending electrodes)
            switch mode
                case 'channels',defnum = sort(this.ChanNum,'ascend');
                case 'electrode',defnum = sort(this.ElecNum,'ascend');
                otherwise, error('Unknown mode ''%s''',mode);
            end
            
            % convert ascending electrode numbers into channels
            if strcmpi(mode,'electrode')
                defnum = el2ch(this,defnum);
            end
            
            % allow user to provide their own ordering of the channel or
            % electrode numbers
            [varargin,num] = util.argkeyval('num',varargin,defnum);
            [varargin,FlagInterp] = util.argflag('interpolate',varargin);
            util.argempty(varargin);
            
            % re-sort the input data as ascending channels
            [channels,sortIdx] = sort(num,'ascend');
            vec = vec(sortIdx);
            
            % map vector into rows x cols matrix
            numcol = max(this.Column) - min(this.Column) + 1;
            numrow = max(this.Row) - min(this.Row) + 1;
            lt = nan(numrow,numcol);
            [c,r] = ch2cr(this,channels);
            [x,y] = cr2xy(this,c,r);
            for ch=1:length(channels)
                lt(y(ch),x(ch)) = vec(ch);
            end
            lt = flipud(lt);
            
            % interpolate values into the empty positions
            if FlagInterp
                [nanX,nanY] = find(isnan(lt));
                for nn=1:length(nanX)
                    x=nanX(nn);
                    y=nanY(nn);
                    if x==1 && y==1
                        lt(x,y) = nanmean([lt(2,1) lt(2,2) lt(1,2)]);
                    elseif x==1 && y==10
                        lt(x,y) = nanmean([lt(9,1) lt(9,2) lt(10,2)]);
                    elseif x==10 && y==10
                        lt(x,y) = nanmean([lt(10,9) lt(9,9) lt(9,10)]);
                    elseif x==10 && y==1
                        lt(x,y) = nanmean([lt(1,9) lt(2,9) lt(2,10)]);
                    else
                        lt(x,y) = nanmean([...
                            lt(x-1,y-1) lt(x,y-1) lt(x+1,y-1) ...
                            lt(x-1,y) lt(x,y) lt(x+1,y) ...
                            lt(x-1,y+1) lt(x,y+1) lt(x+1,y+1)]);
                    end
                end
            end
        end % END function vec2layout
        
        function [seps,pairseps,varargout] = persep(this,fn,data,varargin)
            % PERSEP Perform an operation on data from common separations
            %
            %    [SEPS,CHPAIRSEPS,ARG1,ARG2,...] = PERSEP(THIS,FN,DATA)
            %    For values in MxN matrix DATA, with M observations for N 
            %    channel pairs, execute the function FN for data from each
            %    pair of channels at the unique separation distance P(i).  
            %    SEPS will contain the P separation distances and PAIRSEPS
            %    will be a Px3 matrix containing the channel pairs and 
            %    their separation distances.  Outputs from the function FN
            %    will be returned in the same order and quantity they were
            %    obtained from FN as outputs following SEPS and PAIRSEPS.
            %    FN may be a function handle, or a cell array in which the
            %    first cell is a function handle and the remaining cells
            %    are arguments provided to the function prior to the data
            %    input.
            %
            %      Example:
            %      >> [seps,pairseps,mval] = persep(this,@mean,data);
            %
            %    In this example, DATA contains M observations for 96
            %    channels.  MVAL will contain the average value of the M
            %    observations for the channels for each unique separation
            %    distance.
            
            % process options
            [varargin,chlist] = util.argkeyval('chlist',varargin,1:96);
            [varargin,badchan] = util.argkeyval('badchan',varargin,[]);
            [varargin,mode] = util.argkeyval('mode',varargin,'channel',[],{'electrode','channel'});
            [varargin,args] = util.argkeyval('args',varargin,{});
            util.argempty(varargin);
            
            % validate data
            assert(ismember(length(chlist),size(data)),'Data input must have 96 rows or columns');
            if size(data,1)==length(chlist),data=data';end
            
            % validation function
            fn = util.ascell(fn);
            assert(isa(fn{1},'function_handle'),'Must provide a function handle or cell array in which first cell is a function handle and subsequent cells are arguments to the function');
            
            % generate list of unique channel pairs
            pairlist = nchoosek(chlist,2);
            
            % figure separation distances between electrodes
            pairseps = nan(size(pairlist,1),1);
            for pp=1:length(pairseps)
                switch mode
                    case 'electrode'
                        [r1,c1] = ch2cr(el2ch(this,pairlist(pp,1)));
                        [r2,c2] = ch2cr(el2ch(this,pairlist(pp,2)));
                    case 'channel'
                        [r1,c1] = ch2cr(this,pairlist(pp,1));
                        [r2,c2] = ch2cr(this,pairlist(pp,2));
                    otherwise
                        error('Unknown mode ''%s''',mode);
                end
                if ~isempty(r1) && ~isempty(r2)
                    x = this.spacing*abs(r1-r2);
                    y = this.spacing*abs(c1-c2);
                    pairseps(pp) = round(sqrt(x^2+y^2)*1000)/1000;
                end
            end
            seps = unique(pairseps(~isnan(pairseps)));
            
            % set pair separations involving bad channels to -1
            pairseps( ismember(pairlist(:,1),badchan)|ismember(pairlist(:,2),badchan) ) = -1;
            
            % execute user function for data from first separation distance
            tmpargout = feval(fn{:},data(:,pairseps==seps(1),:),args{:});
            tmpargout = util.ascell(tmpargout);
            nrg = length(tmpargout);
            argout = cell(1,length(seps));
            
            % loop over separation distances
            mvals = zeros(size(data,1),length(seps));
            sevals = zeros(size(data,1),length(seps));
            for pp=1:length(seps)
                rel=data(:,pairseps==seps(pp),:);
                mvals(:,pp)=nanmean(rel(:,:),2);
                sevals(:,pp)=nanstd(rel(:,:),[],2)/sqrt(size(rel,2));
            end
        end % END function persep
        
        function save(this,target)
            % SAVE Create a *.cmap file
            %
            %   SAVE(THIS,TGT)
            %   Create a map file at the path provided in TGT.  The file
            %   cannot already exist.
            
            % make sure file doesn't already exist
            assert(exist(target,'file')~=2,'Target file ''%s'' already exists',target);
            
            % open the file for writing
            fid = fopen(target,'w');
            
            % enclose in try/catch so that we can close the file on error
            try
                % write the map file header
                for kk=1:length(this.MapFileHeader)
                    fprintf(fid,'%s\n',this.MapFileHeader{kk});
                end
                
                % write the map data
                elecs = sort(this.ElecNum,'descend');
                for kk=1:length(elecs)
                    [col,row] = this.el2cr(elecs(kk));
                    bank = this.el2b(elecs(kk));
                    pin = this.el2p(elecs(kk));
                    label = this.el2lbl(elecs(kk));
                    fprintf(fid,'%d\t%d\t%s\t%d\t%s\n',col,row,char(bank+'@'),pin,label);
                end
            catch ME
                
                % print the error message
                util.errorMessage(ME);
            end
            
            % close the file
            fclose(fid);
        end % END function save
    end % END methods
end % END classdef ArrayMap