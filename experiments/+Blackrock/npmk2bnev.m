function bnev = npmk2bnev(npmk,mapfile)
% NPMK2BNEV convert NPMK NEV struct to Blackrock.NEV format
%
%   BNEV = NPMK2BNEV(NPMK)
%   Convert the struct NPMK, generated by the Blackrock NPMK code, into a
%   Blackrock.NEV struct.
%
%   See also BLACKROCK.NEV, OPENNEV.
%
% CURRENT PROBLEM: If a particular data type occurred at a timestamp that
% is ambiguous due to multiple recording blocks overlapping the smaller
% values, there  is no way to tell which recording block should contain
% that data sample or event.  There are also currently no checks for the
% situation where multiple recording blocks exist, but a particular data
% type did not occur in the first - that data type will all be placed into
% the first cell array although it should go into the second.

% check map file input
hMap = [];
if nargin>1
    if isa(mapfile,'char') && exist(mapfile,'file')==2
        hMap = Blackrock.ArrayMap(mapfile);
    elseif isa(mapfile,'Blackrock.ArrayMap')
        hMap = mapfile;
    else
        error('Unknown data type for mapfile input');
    end
end

% make sure correct input
assert(isfield(npmk,'Data'),'NPMK input must be a struct with ''Data'' field');

% Try to infer recording block information
% look for data type with maximum number of inferred recording blocks
% (count negative sequential difference in timestamp)
% if multiple matches, use the one with the most packets
DataTypes = {'SerialDigitalIO','Spikes','Comments','VideoSync',...
    'Tracking','TrackingEvents','PatientTrigger','Reconfig'};
NumRecordingBlocksAll = zeros(1,length(DataTypes));
NumPacketsAll = zeros(1,length(DataTypes));
for kk=1:length(DataTypes)
    
    % defaults when npmk.Data.(DataTypes{kk}) isn't set
    NumRecordingBlocksEach.(DataTypes{kk}) = 0;
    block.(DataTypes{kk}) = [];
    NumPackets.(DataTypes{kk}) = 0;
    TimestampBoundariesAll.(DataTypes{kk}) = 0;
    
    % process timestamps/recording blocks/packet counts
    if isfield(npmk.Data,DataTypes{kk}) && ~isempty(npmk.Data.(DataTypes{kk})) && isstruct(npmk.Data.(DataTypes{kk})) && isfield(npmk.Data.(DataTypes{kk}),'TimeStamp')
        
        if isempty(npmk.Data.(DataTypes{kk}).TimeStamp)
            
            % no recording blocks
            NumRecordingBlocksEach.(DataTypes{kk}) = 0;
            block.(DataTypes{kk}) = [];
            
            % no packets
            NumPackets.(DataTypes{kk}) = length(npmk.Data.(DataTypes{kk}).TimeStamp);
            TimestampBoundariesAll.(DataTypes{kk}) = NumPackets.(DataTypes{kk});
            
        else
            
            % count number of recording blocks
            NumRecordingBlocksEach.(DataTypes{kk}) = 1;
            block.(DataTypes{kk}) = find(diff(npmk.Data.(DataTypes{kk}).TimeStamp)<0)+1;
            if ~isempty(block.(DataTypes{kk}))
                NumRecordingBlocksEach.(DataTypes{kk}) = numel(block.(DataTypes{kk}))+1;
            end
            
            % count the number of packets in each block
            NumPackets.(DataTypes{kk}) = zeros(1,NumRecordingBlocksEach.(DataTypes{kk}));
            TimestampBoundariesAll.(DataTypes{kk}) = zeros(1,NumRecordingBlocksEach.(DataTypes{kk}));
            for nn=1:NumRecordingBlocksEach.(DataTypes{kk})
                st = 1;
                lt = length(npmk.Data.(DataTypes{kk}).TimeStamp);
                if nn~=1,st=block.(DataTypes{kk})(nn-1);end
                if length(block.(DataTypes{kk}))>=nn,lt=block.(DataTypes{kk})(nn)-1;end
                if isempty(lt)||isempty(st),continue;end
                NumPackets.(DataTypes{kk})(nn) = lt-st+1;
                TimestampBoundariesAll.(DataTypes{kk})(nn) = npmk.Data.(DataTypes{kk}).TimeStamp(lt);
            end
        end
        
        % save information
        NumRecordingBlocksAll(kk) = NumRecordingBlocksEach.(DataTypes{kk});
        NumPacketsAll(kk) = length(npmk.Data.(DataTypes{kk}).TimeStamp);
    end
end

% validate packet count
assert(sum(NumPacketsAll)==npmk.MetaTags.PacketCount,'Mismatched packet count!');

% look for most recording blocks
whichRB = find(NumRecordingBlocksAll==max(NumRecordingBlocksAll));
assert(~isempty(whichRB),'Could not identify a maximum number of recording blocks');

% of these, choose the one with the most packets
[~,whichPK] = max(NumPacketsAll(whichRB));
assert(~isempty(whichPK),'Could not identify a maximum number of packets');
modelDataType = DataTypes{whichRB(whichPK(1))};
NumRecordingBlocks = NumRecordingBlocksAll(whichRB(whichPK(1)));

% try to match up recording blocks to the model if needed
if numel(unique(NumRecordingBlocksAll(NumRecordingBlocksAll>0)))>1
    modelBoundaries = TimestampBoundariesAll.(modelDataType);
    for kk=1:length(DataTypes)
        if strcmpi(DataTypes{kk},modelDataType)
            blockAssignments.(DataTypes{kk}) = 1:NumRecordingBlocks;
        else
            blockAssignments.(DataTypes{kk}) = zeros(1,NumRecordingBlocks);
            currBlock = 1;
            for bb=1:NumRecordingBlocksEach.(DataTypes{kk})
                if TimestampBoundariesAll.(DataTypes{kk})(bb) < modelBoundaries(currBlock)
                    blockAssignments.(DataTypes{kk})(bb) = currBlock;
                end
                currBlock = currBlock + 1;
            end
        end
    end
end

% object properties
bnev.verbosity = env.get('verbosity');
bnev.debug = env.get('debug');
bnev.hArrayMap = [];
if ~isempty(hMap)
    bnev.hArrayMap = hMap;
end
bnev.SourceDataLoaded = 1;
bnev.SourceDirectory = npmk.MetaTags.FilePath;
bnev.SourceBasename = npmk.MetaTags.Filename;
bnev.SourceExtension = '.nev';
bnev.SourceFileSize = npmk.MetaTags.HeaderOffset + npmk.MetaTags.PacketCount*npmk.MetaTags.PacketBytes;
bnev.AllSpikeWaveform16Bit = str2double(npmk.MetaTags.Flags(end));
bnev.FileTypeID = npmk.MetaTags.FileTypeID;
fsplit = strsplit(npmk.MetaTags.FileSpec,'.');
bnev.FileSpecMajor = fsplit{1};
bnev.FileSpecMinor = fsplit{2};
bnev.AdditionalFlags = bin2dec(npmk.MetaTags.Flags);
bnev.BytesInHeaders = npmk.MetaTags.HeaderOffset;
bnev.BytesPerDataPacket = npmk.MetaTags.PacketBytes;
bnev.ResolutionTimestamps = npmk.MetaTags.TimeRes;
bnev.ResolutionSamples = npmk.MetaTags.SampleRes;
bnev.OriginTimeString = npmk.MetaTags.DateTime;
bnev.OriginTimeDatenum = npmk.MetaTags.DateTimeRaw;
bnev.ApplicationName = npmk.MetaTags.Application;
bnev.Comment = npmk.MetaTags.Comment;
bnev.NumExtendedHeaders = 3*length(npmk.ElectrodesInfo) + length(npmk.IOLabels); % WARNING this calculation does not account for some extended header types
bnev.ArrayName = []; % HARDCODED
bnev.ExtraComment = npmk.MetaTags.Comment;
bnev.ExtHeaderIndicatedMapFile = 0; % questionable what this should be (NEV doesn't indicate)

% ChannelInfo
bnev.ChannelInfo(length(npmk.ElectrodesInfo)) = struct(...
    'ChannelID',[],'PhysicalConnector',[],'ConnectorPin',[],...
    'DigitizationFactor',[],'EnergyThreshold',[],'HighThreshold',[],...
    'LowThrehsold',[],'NumSortedUnits',[],'BytesPerWaveformSample',[],...
    'Label',[],'HighFreqCorner',[],'HighFreqOrder',[],...
    'HighFilterType',[],'LowFreqCorner',[],'LowFreqOrder',[],...
    'LowFilterType',[]);
for kk=1:length(bnev.ChannelInfo)
    bnev.ChannelInfo(kk).ChannelID = npmk.ElectrodesInfo(kk).ElectrodeID;
    bnev.ChannelInfo(kk).PhysicalConnector = npmk.ElectrodesInfo(kk).ConnectorBank;
    bnev.ChannelInfo(kk).ConnectorPin = npmk.ElectrodesInfo(kk).ConnectorPin;
    bnev.ChannelInfo(kk).DigitizationFactor = npmk.ElectrodesInfo(kk).DigitalFactor;
    bnev.ChannelInfo(kk).EnergyThreshold = npmk.ElectrodesInfo(kk).EnergyThreshold;
    bnev.ChannelInfo(kk).HighThreshold = npmk.ElectrodesInfo(kk).HighThreshold;
    bnev.ChannelInfo(kk).LowThreshold = npmk.ElectrodesInfo(kk).LowThreshold;
    bnev.ChannelInfo(kk).NumSortedUnits = npmk.ElectrodesInfo(kk).Units;
    bnev.ChannelInfo(kk).BytesPerWaveformSample = npmk.ElectrodesInfo(kk).WaveformBytes;
    bnev.ChannelInfo(kk).SpikeWidthSamples = 48; % HARDCODED
    if isempty(hMap)
        bnev.ChannelInfo(kk).ElectrodeID = [];
    else
        bnev.ChannelInfo(kk).ElectrodeID = hMap.ch2el(bnev.ChannelInfo(kk).ChannelID);
    end
    bnev.ChannelInfo(kk).Label = npmk.ElectrodesInfo(kk).ElectrodeLabel;
    bnev.ChannelInfo(kk).HighFreqCorner = npmk.ElectrodesInfo(kk).HighFreqCorner;
    bnev.ChannelInfo(kk).HighFreqOrder = npmk.ElectrodesInfo(kk).HighFreqOrder;
    bnev.ChannelInfo(kk).HighFilterType = npmk.ElectrodesInfo(kk).HighFilterType;
    bnev.ChannelInfo(kk).LowFreqCorner = npmk.ElectrodesInfo(kk).LowFreqCorner;
    bnev.ChannelInfo(kk).LowFreqOrder = npmk.ElectrodesInfo(kk).LowFreqOrder;
    bnev.ChannelInfo(kk).LowFilterType = npmk.ElectrodesInfo(kk).LowFilterType;
end

% DigitalInfo
bnev.DigitalInfo(length(npmk.IOLabels)) = struct('Label',[],'Mode',[]);
for kk=1:length(npmk.IOLabels)
    bnev.DigitalInfo(kk).Label = deblank(npmk.IOLabels{kk});
    switch lower(bnev.DigitalInfo(kk).Label)
        case 'serial'
            bnev.DigitalInfo(kk).Mode = 'serial';
        case 'digin'
            bnev.DigitalInfo(kk).Mode = 'parallel';
        otherwise
            bnev.DigitalInfo(kk).Mode = [];
    end
end

% VideoInfo
bnev.VideoInfo = []; % HARDCODED

% TrackingInfo
bnev.TrackingInfo = []; % HARDCODED

% additional properties
bnev.NumRecordingBlocks = NumRecordingBlocks;
bnev.RecordingBlockPacketCount = zeros(1,NumRecordingBlocks);
bnev.RecordingBlockPacketIdx = zeros(NumRecordingBlocks,2);
st = 1;
for kk=1:NumRecordingBlocks
    bnev.RecordingBlockPacketCount(kk) = 0;
    for bb=1:length(DataTypes)
        bnev.RecordingBlockPacketCount(kk) = bnev.RecordingBlockPacketCount(kk) + NumPackets.(DataTypes{bb})(kk);
    end
    bnev.RecordingBlockPacketIdx(kk,:) = [st st+bnev.RecordingBlockPacketCount(kk)-1];
    st = st + bnev.RecordingBlockPacketCount(kk);
end
bnev.NumDataPackets = sum(NumPacketsAll);

% Timestamps
bnev.Timestamps = cell(1,NumRecordingBlocks);
bnev.PacketIDs = cell(1,NumRecordingBlocks);
bnev.UniquePacketIDs = cell(1,NumRecordingBlocks);
for kk=1:NumRecordingBlocks
    bnev.Timestamps{kk} = [];
    bnev.PacketIDs{kk} = [];
    for bb=1:length(DataTypes)
        
        % skip if no timestamps
        if ~isfield(npmk.Data,DataTypes{bb}) || ~isfield(npmk.Data.(DataTypes{bb}),'TimeStamp') || isempty(npmk.Data.(DataTypes{bb}).TimeStamp)
            continue;
        end
        
        % identify indices for this recording block / data type
        st = 1;
        lt = length(npmk.Data.(DataTypes{bb}).TimeStamp);
        if kk~=1,st=block.(DataTypes{bb})(kk-1);end
        if length(block.(DataTypes{bb}))>=kk,lt=block.(DataTypes{bb})(kk)-1;end
        if isempty(lt)||isempty(st),continue;end
        
        % add timestamps from this data source
        bnev.Timestamps{kk} = [bnev.Timestamps{kk} npmk.Data.(DataTypes{bb}).TimeStamp(st:lt)];
        
        % identify packet ID for this data source
        switch DataTypes{bb}
            case 'SerialDigitalIO', pid=0;
            case 'Spikes',pid = double(npmk.Data.(DataTypes{bb}).Electrode);
            case 'Comments',pid=65535;
            case 'VideoSync',pid=65534;
            case 'Tracking',pid=65533;
            case 'ButtonTrigger',pid=65532;
            case 'Configuration',pid=65531;
            otherwise,error('Unknown data type ''%s''',DataTypes{bb});
        end
        
        % add packet IDs from this data source
        bnev.PacketIDs{kk} = [bnev.PacketIDs{kk} pid.*ones(1,lt-st+1)];
    end
    
    % sort the Timestamps and apply sorting to PacketIDs
    [bnev.Timestamps{kk},idx] = sort(bnev.Timestamps{kk},'ascend');
    bnev.PacketIDs{kk} = bnev.PacketIDs{kk}(idx);
    bnev.UniquePacketIDs{kk} = unique(bnev.PacketIDs{kk});
end
bnev.majorVersion = 1; % HARDCODED
bnev.minorVersion = 0; % HARDCODED
bnev.BasicHeaderSize = 336; % HARDCODED

% Data - SerialDigitalIO
try
    blockIdx = block.(modelDataType);
    bnev.Data.Digital = cell(1,NumRecordingBlocks);
    for bb=1:NumRecordingBlocks
        
        % find start/end of this recording block
        st=1;
        lt=length(npmk.Data.SerialDigitalIO.TimeStamp);
        if bb>1,st=blockIdx(bb-1)+1;end
        if length(blockIdx)>=bb,lt=blockIdx(bb);end
        
        % pull out the data
        bnev.Data.Digital{bb}.RecordingBlock = bb;
        bnev.Data.Digital{bb}.PacketIdx = [];
        bnev.Data.Digital{bb}.TimeStamp = npmk.Data.SerialDigitalIO.TimeStamp(st:lt);
        bnev.Data.Digital{bb}.Flags = [];
        bnev.Data.Digital{bb}.Data = npmk.Data.SerialDigitalIO.UnparsedData(:,st:lt);
    end
catch ME
    util.errorMessage(ME);
    fprintf('Please be aware that this function has not been tested for Serial Digital IO data\n');
end

% Data - Spikes
try
    
    % When synchronizing two NSPs, the clock starts over at zero at some point,
    % producing nonsequential timestamps.  NPMK ignores blocks but
    % Blackrock.NEV returns data by block.
    block.(modelDataType);
    bnev.Data.Spikes = cell(1,NumRecordingBlocks);
    for bb=1:NumRecordingBlocks
        
        % find start/end of this recording block
        st=1;
        lt=length(npmk.Data.Spikes.TimeStamp);
        if bb>1,st=blockIdx(bb-1)+1;end
        if length(blockIdx)>=bb,lt=blockIdx(bb);end
        
        % pull out Spikes data
        bnev.Data.Spikes{bb}.Timestamps = double(npmk.Data.Spikes.TimeStamp(st:lt));
        bnev.Data.Spikes{bb}.Electrode = double(npmk.Data.Spikes.Electrode(st:lt));
        bnev.Data.Spikes{bb}.Unit = double(npmk.Data.Spikes.Unit(st:lt));
        bnev.Data.Spikes{bb}.Waveform = double(npmk.Data.Spikes.Waveform(:,st:lt));
    end
catch ME
    util.errorMessage(ME);
end

% Data - Comments
try
    block.(modelDataType);
    bnev.Data.Comments(NumRecordingBlocks) = struct('RecordingBlock',[],...
        'PacketIdx',[],'Timestamps',[],'CharSet',[],'Color',[],'Text',[]);
    for bb=1:NumRecordingBlocks
        bnev.Data.Comments(bb).RecordingBlock = bb;
        bnev.Data.Comments(bb).PacketIdx = [];
        bnev.Data.Comments(bb).Timestamps = double(npmk.Data.Comments.TimeStamp);
        bnev.Data.Comments(bb).CharSet = double(npmk.Data.Comments.CharSet);
        bnev.Data.Comments(bb).Color = double(npmk.Data.Comments.Color);
        bnev.Data.Comments(bb).Text = cell(1,size(npmk.Data.Comments.Text,1));
        for nn=1:size(npmk.Data.Comments.Text,1)
            bnev.Data.Comments(bb).Text{nn} = deblank(npmk.Data.Comments.Text(bb,:));
        end
    end
catch ME
    util.errorMessage(ME);
end


% % validate file and populate basic fields
% [srcdir,srcbase,srcext] = fileparts(src);
% if isempty(srcdir),srcdir='.';end
% this.SourceDirectory = srcdir;
% this.SourceBasename = srcbase;
% this.SourceExtension = srcext;
% this.SourceFileSize = info.bytes;
% assert(~isempty(this.SourceDirectory)&&~isempty(this.SourceBasename)&&~isempty(this.SourceExtension),'Invalid file ''%s''',src);
% 
% src = fullfile(this.SourceDirectory,[this.SourceBasename this.SourceExtension]);
% tmp = load(src);
% 
% % meta tags
% this.OriginTimeString = tmp.NEV.MetaTags.DateTime;
% this.ResolutionSamples = tmp.NEV.MetaTags.SampleRes;
% this.Comment = tmp.NEV.MetaTags.Comment;
% this.FileTypeID = tmp.NEV.MetaTags.FileTypeID;
% this.AdditionalFlags = bin2dec(tmp.NEV.MetaTags.Flags);
% this.OriginTimeDatenum = tmp.NEV.MetaTags.DateTimeRaw;
% verstr = strsplit(tmp.NEV.MetaTags.FileSpec,'.');
% this.FileSpecMajor = str2double(verstr{1});
% this.FileSpecMinor = str2double(verstr{2});
% this.BytesPerDataPacket = tmp.NEV.MetaTags.PacketBytes;
% this.BytesInHeaders = tmp.NEV.MetaTags.HeaderOffset;
% this.ResolutionTimestamps = tmp.NEV.MetaTags.TimeRes;
% this.ApplicationName = tmp.NEV.MetaTags.Application;
% this.SourceBasename = tmp.NEV.MetaTags.Filename;
% this.SourceDirectory = tmp.NEV.MetaTags.FilePath;
% % st.MetaTags.DataDuration = this.Timestamps{end}(end);
% % st.MetaTags.DataDurationSec = this.Timestamps{end}(end)/this.ResolutionSamples;
% % st.MetaTags.PacketCount = sum(this.RecordingBlockPacketCount);
% % st.MetaTags.ChannelID = [this.ChannelInfo.ChannelID];
% 
% % ElectrodesInfo
% for kk=1:length(this.ChannelInfo)
%     this.ChannelInfo(kk).ChannelID = tmp.NEV.ElectrodesInfo(kk).ElectrodeID;
%     this.ChannelInfo(kk).PhysicalConnector = tmp.NEV.ElectrodesInfo(kk).ConnectorBank;
%     this.ChannelInfo(kk).ConnectorPin = tmp.NEV.ElectrodesInfo(kk).ConnectorPin;
%     this.ChannelInfo(kk).DigitizationFactor = tmp.NEV.ElectrodesInfo(kk).DigitalFactor;
%     this.ChannelInfo(kk).EnergyThreshold = tmp.NEV.ElectrodesInfo(kk).EnergyThreshold;
%     this.ChannelInfo(kk).HighThreshold = tmp.NEV.ElectrodesInfo(kk).HighThreshold;
%     this.ChannelInfo(kk).LowThreshold = tmp.NEV.ElectrodesInfo(kk).LowThreshold;
%     this.ChannelInfo(kk).NumSortedUnits = tmp.NEV.ElectrodesInfo(kk).Units;
%     this.ChannelInfo(kk).BytesPerWaveformSample = tmp.NEV.ElectrodesInfo(kk).WaveformBytes;
%     this.ChannelInfo(kk).Label = tmp.NEV.ElectrodesInfo(kk).ElectrodeLabel;
%     this.ChannelInfo(kk).HighFreqCorner = tmp.NEV.ElectrodesInfo(kk).HighFreqCorner;
%     this.ChannelInfo(kk).HighFreqOrder = tmp.NEV.ElectrodesInfo(kk).HighFreqOrder;
%     this.ChannelInfo(kk).HighFilterType = tmp.NEV.ElectrodesInfo(kk).HighFilterType;
%     this.ChannelInfo(kk).LowFreqCorner = tmp.NEV.ElectrodesInfo(kk).LowFreqCorner;
%     this.ChannelInfo(kk).LowFreqOrder = tmp.NEV.ElectrodesInfo(kk).LowFreqOrder;
%     this.ChannelInfo(kk).LowFilterType = tmp.NEV.ElectrodesInfo(kk).LowFilterType;
% end
% 
% % IOLabels
% for kk=1:length(tmp.NEV.IOLabels)
%     this.DigitalInfo(kk).Label = strtrim(tmp.NEV.IOLabels{kk});
% end
% end % END function fromNPMK