function nevfile = npmk2nev(npmk,varargin)
% NPMK2NEV Convert NPMK struct to NEV file
%
%   NPMK2NEV(NPMK)
%   Convert the struct NPMK, generated by the Blackrock NPMK code, into a
%   NEV file.
%
%   See also BLACKROCK.NEV, OPENNEV.
[varargin,fileappend] = util.ProcVarargin(varargin,'append','_fromNPMK');

% process npmk input
defaultNEVFile = '';
if ischar(npmk) && exist(npmk,'file')==2
    [npmkdir,npmkbase] = fileparts(npmk);
    defaultNEVFile = fullfile(npmkdir,sprintf('%s%s.nev',npmkbase,fileappend));
    npmk = load(npmk);
    assert(isfield(npmk,'NEV'),'Must provide path to file with NEV struct in it');
    npmk = npmk.NEV;
end
assert(isstruct(npmk)&&isfield(npmk,'Data'),'Invalid NPMK input: must provide either full path to MAT file with NEV struct, or the NEV struct itself');
assert(isfield(npmk.Data,'Spikes'),'NPMK input must contain Spike data');
if isempty(defaultNEVFile) && exist(npmk.MetaTags.FilePath,'dir')==7
    defaultNEVFile = fullfile(npmk.MetaTags.FilePath,sprintf('%s%s.nev',npmk.MetaTags.Filename,fileappend));
end

% process varargin
[varargin,hMap] = util.ProcVarargin(varargin,@(x)isa(x,'Blackrock.ArrayMap'),Blackrock.ArrayMap('quiet'));
defaultSrcNEV = fullfile(npmk.MetaTags.FilePath,sprintf('%s.nev',npmk.MetaTags.Filename));
if exist(defaultSrcNEV,'file')~=2
    warning('NPMK source NEV file does not exist: %s\n',defaultSrcNEV);
    defaultSrcNEV = '';
end
[varargin,srcNEV] = util.ProcVarargin(varargin,'like',defaultSrcNEV);
assert(~isempty(srcNEV),'Must provide a source NEV file or Blackrock.NEV object');
if ischar(srcNEV)
    assert(exist(srcNEV,'file')==2,'Must provide the full path to an existing NEV file');
    srcNEV = Blackrock.NEV(srcNEV,hMap);
end
assert(isa(srcNEV,'Blackrock.NEV'),'Must provide a valid Blackrock.NEV object for ''like'' input, not ''%s''',class(srcNEV));
if isempty(defaultNEVFile) && exist(srcNEV.SourceDirectory,'dir')==7
    defaultNEVFile = fullfile(srcNEV.SourceDirectory,sprintf('%s%s%s',srcNEV.SourceBasename,fileappend,srcNEV.SourceExtension));
end
[varargin,nevfile] = util.ProcVarargin(varargin,'nevfile',defaultNEVFile);
[varargin,flagBasicHeader] = util.ProcVarargin(varargin,'basicheaders',false);
[varargin,flagExtendedHeaders] = util.ProcVarargin(varargin,'extheaders',false);
util.ProcVarargin(varargin);

% process NEV file input
assert(ischar(nevfile)&&~isempty(nevfile),'Must provide full path to output file as char, not ''%s''',class(nevfile));
[~,~,ext] = fileparts(nevfile);
assert(strcmpi(ext,'.nev'),'Must provide full path to a NEV file, not ''%s''',ext);
assert(exist(nevfile,'file')~=2,'Target file ''%s'' already exists',nevfile);

% we have a source NEV file, so pull necessary information from the
% Blackrock.NEV file. validate equivalence of the NEV and NPMK data
tmpdt = srcNEV.read('all');
dataTypes = fieldnames(tmpdt);
for kk=1:length(dataTypes)
    if isempty(tmpdt.(dataTypes{kk}))
        tmpdt = rmfield(tmpdt,dataTypes{kk});
    else
        tmpdt.(dataTypes{kk}) = util.ascell(tmpdt.(dataTypes{kk}));
    end
end
dataTypes = fieldnames(tmpdt);
numDataPackets = sum(cellfun(@(x)length(x.Timestamps),tmpdt.Spike));
assert(numDataPackets==length(npmk.Data.Spikes.TimeStamp),'Source NEV and NPMK structure must have sample number of data packets');

% determine number of recording blocks, packets for each data type
numRecordingBlocksAll = cellfun(@(x)length(tmpdt.(x)),dataTypes);
numRecordingBlocks = max(numRecordingBlocksAll);
assert(all(numRecordingBlocksAll==numRecordingBlocks),'Must have same number of recording blocks for each data type');

% create the Blackrock.NEVWriter object
nvw = Blackrock.NEVWriter(nevfile,'like',srcNEV);

% check how many recording blocks (cells)
for kk=1:numRecordingBlocks
    
    % loop over data types and substitute in the NPMK data
    arg = cell(1,length(dataTypes));
    for nn=1:length(dataTypes)
        arg{nn} = tmpdt.(dataTypes{nn}){kk};
        
        % get the timestamps from both NEV and NPMK data
        nv_timestamps = arg{nn}.Timestamps(:);
        switch dataTypes{nn}
            case 'Spike',   npmk_timestamps = double(npmk.Data.Spikes.TimeStamp(:));
            case 'Comment', npmk_timestamps = double(npmk.Data.Comments.TimeStamp(:));
            case 'Digital', npmk_timestamps = double(npmk.Data.SerialDigitalIO.TimeStamp(:));
            case 'Video',   npmk_timestamps = double(npmk.Data.VideoSync.TimeStamp(:));
            case 'Tracking',npmk_timestamps = double(npmk.Data.TrackingEvents.TimeStamp(:));
            case 'Button',  npmk_timestamps = double(npmk.Data.PatientTrigger.TimeStamp(:));
            case 'Config',  npmk_timestamps = double(npmk.Data.Reconfig.TimeStamp(:));
            otherwise,      error('Unknown data field ''%s''',dataTypes{nn});
        end
        
        % try to match up the NEV's recording block timestamps with NPMK
        idx = find(npmk_timestamps==nv_timestamps(1));
        assert(~isempty(idx),'No matching starting timestamp for data type ''%s'', recording block %d',dataTypes{nn},kk);
        which = nan;
        for ii=1:length(idx)
            if (idx(ii) + length(nv_timestamps) - 1) > length(npmk_timestamps)
                
                % we know already it's no match because not enough
                continue;
            end
            if all(npmk_timestamps(idx(ii) + (0:length(nv_timestamps)-1)) == nv_timestamps)
                which = ii;
                break;
            end
        end
        assert(~isnan(which),'Could not identify the NPMK segment for data type ''%s'', recording block %d',dataTypes{nn},kk);
        
        % now replace appropriate data
        idxsrc = idx(which) + (0:(length(nv_timestamps)-1))';
        switch dataTypes{nn}
            case 'Spike'
                arg{nn}.Units = double(npmk.Data.Spikes.Unit(idxsrc));
                arg{nn}.Units = arg{nn}.Units(:);
                arg{nn}.Waveforms = double(npmk.Data.Spikes.Waveform(:,idxsrc));
            case 'Comment'
                arg{nn}.CharSet = uint8(npmk.Data.Comments.CharSet(idxsrc));
                arg{nn}.CharSet = arg{nn}.CharSet(:);
                arg{nn}.Color = uint32(npmk.Data.Comments.Color(idxsrc));
                arg{nn}.Color = arg{nn}.Color(:);
                if size(npmk.Data.Comments.Text,1)~=length(arg{nn}.Text) || size(npmk.Data.Comments.Text,2)~=92
                    if numel(npmk.Data.Comments.Text)/92 == length(arg{nn}.Text)
                        npmk.Data.Comments.Text = reshape(npmk.Data.Comments.Text,[numel(npmk.Data.Comments.Text)/92 92]);
                    else
                        warning('The NPMK Comments structure is poorly formed (should be %dx92 char, but instead is %dx%d %s)',length(arg{nn}.Text),size(npmk.Data.Comments.Text,1),size(npmk.Data.Comments.Text,2),class(npmk.Data.Comments.Text));
                    end
                end
                if size(npmk.Data.Comments.Text,1)==length(arg{nn}.Text)
                    arg{nn}.Text = arrayfun(@(x)deblank(npmk.Data.Comments.Text(x,:)),1:size(npmk.Data.Comments.Text,1),'UniformOutput',false);
                    arg{nn}.Text = arg{nn}.Text(:);
                end
            case 'Digital'
                warning('SerialDigitalIO packets not fully supported yet (only UnparsedData will be copied over)');
                arg{nn}.Data = npmk.Data.SerialDigitalIO.UnparsedData;
            case 'Video'
                warning('Video packets not supported yet');
            case 'Tracking'
                warning('Tracking packets not supported yet');
            case 'Button'
                warning('Button packets not supported yet');
            case 'Config'
                warning('Config packets not fully supported yet (only ChangeType will be copied over)');
                arg{nn}.ChangeType = uint16(npmk.Data.Reconfig.ChangeType(idxsrc));
        end
    end
    
    % add the data to the NEV writer object
    nvw.addData(arg{:});
end

% update the basic header
if flagBasicHeader
    nvw.BasicHeader.AdditionalFlags = bin2dec(npmk.MetaTags.Flags);
    nvw.BasicHeader.FileTypeID = npmk.MetaTags.FileTypeID;
    fsplit = strsplit(npmk.MetaTags.FileSpec,'.');
    nvw.BasicHeader.FileSpecMajor = fsplit{1};
    nvw.BasicHeader.FileSpecMinor = fsplit{2};
    nvw.BasicHeader.BytesInHeaders = npmk.MetaTags.HeaderOffset;
    nvw.BasicHeader.BytesPerDataPacket = npmk.MetaTags.PacketBytes;
    nvw.BasicHeader.ResolutionTimestamps = npmk.MetaTags.TimeRes;
    nvw.BasicHeader.ResolutionSamples = npmk.MetaTags.SampleRes;
    nvw.BasicHeader.NumExtendedHeaders = 3*length(npmk.ElectrodesInfo) + length(npmk.IOLabels); % WARNING this calculation does not account for some extended header types
    nvw.BasicHeader.Comment = npmk.MetaTags.Comment;
end

% update extended headers - ChannelInfo
if flagExtendedHeaders
    assert(length(npmk.ElectrodesInfo)==length(srcNEV.ChannelInfo),'NPMK has %d entries in ElectrodesInfo, but NEV has %d in ChannelInfo',length(npmk.ElectrodesInfo),length(srcNEV.ChannelInfo));
    for kk=1:length(npmk.ElectrodesInfo)
        nvw.ExtendedHeaders.ChannelInfo(kk).ChannelID = npmk.ElectrodesInfo(kk).ElectrodeID;
        nvw.ExtendedHeaders.ChannelInfo(kk).PhysicalConnector = npmk.ElectrodesInfo(kk).ConnectorBank;
        nvw.ExtendedHeaders.ChannelInfo(kk).ConnectorPin = npmk.ElectrodesInfo(kk).ConnectorPin;
        nvw.ExtendedHeaders.ChannelInfo(kk).DigitizationFactor = npmk.ElectrodesInfo(kk).DigitalFactor;
        nvw.ExtendedHeaders.ChannelInfo(kk).EnergyThreshold = npmk.ElectrodesInfo(kk).EnergyThreshold;
        nvw.ExtendedHeaders.ChannelInfo(kk).HighThreshold = npmk.ElectrodesInfo(kk).HighThreshold;
        nvw.ExtendedHeaders.ChannelInfo(kk).LowThreshold = npmk.ElectrodesInfo(kk).LowThreshold;
        nvw.ExtendedHeaders.ChannelInfo(kk).NumSortedUnits = npmk.ElectrodesInfo(kk).Units;
        nvw.ExtendedHeaders.ChannelInfo(kk).BytesPerWaveformSample = npmk.ElectrodesInfo(kk).WaveformBytes;
        nvw.ExtendedHeaders.ChannelInfo(kk).SpikeWidthSamples = 48; % HARDCODED
        if isempty(hMap)
            nvw.ExtendedHeaders.ChannelInfo(kk).ElectrodeID = [];
        else
            nvw.ExtendedHeaders.ChannelInfo(kk).ElectrodeID = hMap.ch2el(nvw.ExtendedHeaders.ChannelInfo(kk).ChannelID);
        end
        nvw.ExtendedHeaders.ChannelInfo(kk).Label = npmk.ElectrodesInfo(kk).ElectrodeLabel;
        nvw.ExtendedHeaders.ChannelInfo(kk).HighFreqCorner = npmk.ElectrodesInfo(kk).HighFreqCorner;
        nvw.ExtendedHeaders.ChannelInfo(kk).HighFreqOrder = npmk.ElectrodesInfo(kk).HighFreqOrder;
        nvw.ExtendedHeaders.ChannelInfo(kk).HighFilterType = npmk.ElectrodesInfo(kk).HighFilterType;
        nvw.ExtendedHeaders.ChannelInfo(kk).LowFreqCorner = npmk.ElectrodesInfo(kk).LowFreqCorner;
        nvw.ExtendedHeaders.ChannelInfo(kk).LowFreqOrder = npmk.ElectrodesInfo(kk).LowFreqOrder;
        nvw.ExtendedHeaders.ChannelInfo(kk).LowFilterType = npmk.ElectrodesInfo(kk).LowFilterType;
    end
    
    % update extended headers - DigitalInfo
    assert(length(npmk.IOLabels)==length(srcNEV.DigitalInfo),'NPMK has %d entries in IOLabels, but NEV has %d in DigitalInfo',length(npmk.IOLabels),length(srcNEV.DigitalInfo));
    for kk=1:length(npmk.IOLabels)
        nvw.ExtendedHeaders.DigitalInfo(kk).Label = deblank(npmk.IOLabels{kk});
        switch lower(nvw.ExtendedHeaders.DigitalInfo(kk).Label)
            case 'serial'
                nvw.ExtendedHeaders.DigitalInfo(kk).Mode = 'serial';
            case 'digin'
                nvw.ExtendedHeaders.DigitalInfo(kk).Mode = 'parallel';
            otherwise
                error('Unknown IO label ''%s''',nvw.ExtendedHeaders.DigitalInfo(kk).Label);
        end
    end
end

% save the file
try
    nvw.save;
catch ME
    util.errorMessage(ME);
    return;
end

% update user
fprintf('Created NEV file: %s\n',fullfile(nvw.TargetDirectory,sprintf('%s%s',nvw.TargetBasename,nvw.TargetExtension)));