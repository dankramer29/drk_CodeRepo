function [impedance,channels,electrodes] = processImpedance(impedanceFile,varargin)
% PROCESSIMPEDANCE read and summarize impedance files
%
%   This function reads impedance data from text files generated by the 
%   Impedance Tester which is part of Central (Blackrock Microsystems, Salt
%   Lake City, UT).
%
%   IMPEDANCE = PROCESSIMPEDANCE(FILE)
%   Read impedance data from FILE and return a list of impedance values in
%   IMPEDANCE.
%
%   [IMPEDANCE,CHANNELS,ELECTRODES] = BLACKROCK.PROCESSIMPEDANCE(FILE)
%   Return the channel and electrode number associated with each impedance 
%   value.  Note that if FILE lists electrode numbers, a map file or
%   Blackrock.ArrayMap object must be provided in order to translate
%   electrode numbers to channel numbers.  The same applies for identifying
%   electrode numbers if FILE lists channel numbers.
%
%   PROCESSIMPEDNACE(...,FILEPATH)
%   PROCESSIMPEDANCE(...,ARRAYMAP)
%   Specify an array map either by providing a path to the CMP file or by
%   providing the Blackrock.ArrayMap object directly.
%
%   PROCESSIMPEDANCE(...,'CHANNEL')
%   PROCESSIMPEDANCE(...,'ELECTRODE')
%   Return impedance values sorted by CHANNEL (default) or ELECTRODE.
%
%   PROCESSIMPEDANCE(...,'ROWIDX',IDX)
%   Specify the rows to read out of the impedance file.  Default value is
%   1:96.  Row indices may or may not correspond to either channel or
%   electrode numbers.
%
%   See also BLACKROCK.ARRAYMAP.

% process user inputs
[varargin,SortBy] = util.argkeyword({'CHANNEL','ELECTRODE'},varargin,'CHANNEL',2);
[varargin,rowIdx] = util.argkeyval('ROWIDX',varargin,1:96);
[varargin,hArray] = util.argisa('Blackrock.ArrayMap',varargin,[]);
if isempty(hArray)
    [varargin,hArrayFile] = util.argfn(@(x)ischar(x)&&exist(x,'file')==2&&strcmpi(x(end-min(length(x)-1,3):end),'.cmp'),varargin,'');
    if ~isempty(hArrayFile),hArray=Blackrock.ArrayMap(hArrayFile);end
end
util.argempty(varargin);

% check that file exists
assert(exist(impedanceFile,'file')==2,'File does not exist: %s\n',impedanceFile);

% read in file
fid = fopen(impedanceFile); % open the file
try
    
    % discover how many header lines there are
    flag_found_data = false;
    num_header_lines = 0;
    while ~flag_found_data && ~feof(fid)
        ln = fgetl(fid);
        flag_found_data = isempty(regexpi(ln,'^\*.*$'));
        num_header_lines = num_header_lines + 1;
    end
    fseek(fid,0,'bof');
    
    % read data, skipping header lines
    filedata = textscan(fid,'%s %f %s','HeaderLines',num_header_lines-1); % read info
catch ME
    fclose(fid);
    rethrow(ME);
end
fclose(fid); % close file

% read data, assign to channel based on label
if all(cellfun(@(x)~isempty(x),regexpi(filedata{1}(rowIdx),'^[chanelec]{4}\d{1,2}$')))
    
    % "chanXX" or "elecXX" - standard format
    channels = str2double(strrep(filedata{1}(rowIdx),'chan',''));
    electrodes = str2double(strrep(filedata{1}(rowIdx),'elec',''));
    if ~isempty(hArray)
        chnan = isnan(channels); % can have mixture of labels
        elnan = isnan(electrodes);
        channels(chnan) = hArray.el2ch(electrodes(chnan));
        electrodes(elnan) = hArray.ch2el(channels(elnan));
    end
elseif all(cellfun(@(x)~isempty(x),regexpi(filedata{1}(rowIdx),'^[chanelec]{4}\d-\d{1,2}$')))
    
    % "chanA-BB" or "elecA-BB" - split array format: A/array, B/elec
    % in at least one case, BB is contiguous regardless of A
    channels = regexpi(filedata{1}(rowIdx),'^chan\d-(\d{1,2})$','tokens');
    chempty = cellfun(@isempty,channels);
    channels(~chempty) = cellfun(@(x)str2double(x{1}),channels(~chempty),'UniformOutput',false);
    channels(chempty) = cellfun(@(x)nan,channels(chempty),'UniformOutput',false);
    channels = cellfun(@(x)x,channels);
    electrodes = regexpi(filedata{1}(rowIdx),'^elec\d-(\d{1,2})$','tokens');
    elempty = cellfun(@isempty,electrodes);
    electrodes(~elempty) = cellfun(@(x)str2double(x{1}),electrodes(~elempty),'UniformOutput',false);
    electrodes(elempty) = cellfun(@(x)nan,electrodes(elempty),'UniformOutput',false);
    electrodes = cellfun(@(x)x,electrodes);
    if ~isempty(hArray)
        chnan = isnan(channels); % can have mixture of labels
        elnan = isnan(electrodes);
        channels(chnan) = hArray.el2ch(electrodes(chnan));
        electrodes(elnan) = hArray.ch2el(channels(elnan));
    end
end

% pull out impedance values
impedance = filedata{2}(rowIdx);

% sort by channel (priority) or electrode
if strcmpi(SortBy,'CHANNEL')
    assert(all(~isnan(channels)),'Some impedance values unmatched to any channel, or no map data');
    [channels,sortIdx] = sort(channels);
    electrodes = electrodes(sortIdx);
elseif strcmpi(SortBy,'ELECTRODE')
    assert(all(~isnan(electrodes)),'Some impedance values unmatched to any electrode, or no map data');
    [electrodes,sortIdx] = sort(electrodes);
    channels = channels(sortIdx);
else
    error('unknown sort method "%s" (should be "channel" or "electrode")');
end
impedance = impedance(sortIdx);