function [feats,time,freq] = readNSxBinnedFeatures(featfile,varargin)
% READNSXBINNEDFEATURES read data generated by NSX2BINNEDFEATURES
%
% [S,T,F] = readNSxBinnedFeatures(FILE)
% Read all features from the file specified by FILE.  FILE can be the
% original NSx file, in which case a corresponding BinnedFeature
% file must exist in the same directory, or it can be the BinnedFeature MAT
% file itself.  S is a 3-D matrix with dimensions of frequency, time, and
% channels.  T is a vector of times.  F is a vector of frequency.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[q]uiet')
% Turn off warnings.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[Freq]uencyBand',FREQ)
% Specify the frequencies to be read out as [LOW HIGH] band boundaries.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[pack]et')
% Specify the data packet from which the data will be read.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[time]s',TIME)
% [S,T,F] = readNSxBinnedFeatures(FILE,'[time]s',TIME,'[hour]s')
% [S,T,F] = readNSxBinnedFeatures(FILE,'[time]s',TIME,'[min]utes')
% [S,T,F] = readNSxBinnedFeatures(FILE,'[time]s',TIME,'[sec]onds')
% [S,T,F] = readNSxBinnedFeatures(FILE,'[time]s',TIME,'[milli]seconds')
% Specify the start and end points of the data to be read out.  TIME can be
% a single value, interpreted as total amount of time to read starting from
% the beginning, or a two-element vector specifying start and stop.  By
% default values in TIME will be interpreted as seconds but can be
% interpreted with other units by adding a qualifier 'hours', 'minutes',
% 'seconds', or 'milliseconds'.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[point]s',POINTS)
% Specify the amount of data to read in terms of data points (where each
% point includes one sample from each channel).  POINTS can be a single
% value, specifying total number of points to read starting from beginning,
% or [FIRST LAST] specifying the specific points to read.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[map]file')
% Specify a map file to use for seamless transition between channels and
% electrodes.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[ch]annels',CHANLIST)
% By default, all channels will be read.  Use this option to specify
% specific channels to read.
%
% [S,T,F] = readNSxBinnedFeatures(FILE,'[el]ectrodes',ELECLIST)
% By default, all channels will be read.  Use this option to specify
% specific electrodes to read.  **NOTE that in order to use electrode
% numbers, a map file must be provided as specified above for option
% '[map]file'.

% verbosity
FlagVerbose = true;
if any(strncmpi(varargin,'quiet',1))
    FlagVerbose = false;
end

% frequency band
FrequencyBand = [];
if any(strncmpi(varargin,'FrequencyBand',4))
    idx = find(strncmpi(varargin,'FrequencyBand',4));
    FrequencyBand = varargin{idx+1};
end

% which data packet to read from
UserRequestedPacket = [];
if any(strncmpi(varargin,'packet',4))
    idx = find(strncmpi(varargin,'packet',4));
    UserRequestedPacket = varargin{idx+1};
end
if ~isempty(UserRequestedPacket) && length(UserRequestedPacket)>1
    error('Can only request data from one packet at a time');
end

% which data points to read
UserRequestedTimes = [];
UserRequestedPoints = [];
if any(strncmpi(varargin,'times',4))
    TimeFactor = 1; % will be in terms of final (downsampled) sampling rate
    if any(strncmpi(varargin,'hours',4))
        TimeFactor = 60*60;
    elseif any(strncmpi(varargin,'minutes',3))
        TimeFactor = 60;
    elseif any(strncmpi(varargin,'seconds',3))
        TimeFactor = 1;
    elseif any(strncmpi(varargin,'milliseconds',5))
        TimeFactor = 1/1000;
    end
    idx = find(strncmpi(varargin,'times',4));
    if length(varargin{idx+1})==1
        UserRequestedTimes = [0 varargin{idx+1}]; % indicate total time required
    else
        UserRequestedTimes = [varargin{idx+1}(1) varargin{idx+1}(end)]; % indicate start and stop
    end
    UserRequestedTimes = UserRequestedTimes*TimeFactor;
elseif any(strncmpi(varargin,'points',5))
    idx = find(strncmpi(varargin,'points',5));
    if length(varargin{idx+1})==1
        UserRequestedPoints = [1 varargin{idx+1}]; % indicate total number of points required
    else
        UserRequestedPoints = [varargin{idx+1}(1) varargin{idx+1}(end)]; % indicate start and stop
    end
end

% which channels to read
hArrayMap = [];
UserRequestedChannels = [];
if any(strncmpi(varargin,'mapfile',3))
    idx = find(strncmpi(varargin,'mapfile',3));
    hArrayMap = Blackrock.ArrayMap(varargin{idx+1});
end
if any(strncmpi(varargin,'channels',2))
    idx = find(strncmpi(varargin,'channels',2));
    UserRequestedChannels = varargin{idx+1};
elseif any(strncmpi(varargin,'electrodes',2))
    if isempty(hArrayMap)
        error('Must provide map file when using electrodes instead of channels');
    end
    idx = find(strncmpi(varargin,'electrodes',2));
    UserRequestedChannels = hArrayMap.el2ch(varargin{idx+1});
end
if ~isempty(UserRequestedChannels)
    UserRequestedChannels = sort(unique(UserRequestedChannels),'ascend');
end

% look for feature file, or (eventually) create the feature file if it
% doesn't exist
[fdir,fbasename,fext] = fileparts(featfile);
if strcmpi(fext(2:3),'ns')
    featfile = fullfile(fdir,[fbasename '_' lower(fext(2:end)) '_BinnedFeatures.mat']);
end
if exist(featfile,'file')~=2
    error('Feature file ''%s'' does not exist.');
    %Blackrock.NSx2BinnedFeatures(featfile,
end

% check file contents
info = whos('-file',featfile);
vars = {info.name};
if ~any(ismember(vars,'PacketIDs')) || ~any(ismember(vars,'Parameters'))
    error('Invalid feature file ''%s''',featfile);
end
fl = load(featfile,'Parameters');
Parameters = fl.Parameters;
clear fl;
if ~isfield(Parameters,'Time')
    error('Invalid feature file ''%s''',featfile);
end

% calculate parameters, set defaults if left empty by user
NumPackets = length(Parameters);
NumWindowsPerPacket = zeros(1,NumPackets);
for pp = 1:NumPackets
    NumWindowsPerPacket(pp) = length(Parameters(pp).Time);
end
if isempty(UserRequestedPacket)
    [~,UserRequestedPacket] = max(NumWindowsPerPacket);
end
if isempty(UserRequestedChannels)
    UserRequestedChannels = Parameters(UserRequestedPacket).ChannelIDs;
end
if isempty(FrequencyBand)
    FrequencyBand = Parameters(UserRequestedPacket).FrequencyBand;
end
FeatureFs = 1/Parameters(UserRequestedPacket).MovingWindow(2);
if isempty(UserRequestedTimes)
    if ~isempty(UserRequestedPoints)
        st = round((UserRequestedPoints-1)/FeatureFs);
        lt = st + round((diff(UserRequestedPoints)+1)/FeatureFs);
        UserRequestedTimes = [st lt];
    else
        UserRequestedTimes = Parameters(UserRequestedPacket).Time([1 end]);
    end
end
if UserRequestedTimes(1) < Parameters(UserRequestedPacket).Time(1)
    UserRequestedTimes(1) = Parameters(UserRequestedPacket).Time(1);
    if FlagVerbose
        warning('Start time set to minimum available: %.2f sec',UserRequestedTimes(1));
    end
end
if UserRequestedTimes(2) > Parameters(UserRequestedPacket).Time(end)
    UserRequestedTimes(2) = Parameters(UserRequestedPacket).Time(end);
    if FlagVerbose
        warning('End time set to maximum available: %.2f sec',UserRequestedTimes(2));
    end
end

% pull out the data
stIdx = find(Parameters(UserRequestedPacket).Time>=UserRequestedTimes(1),1,'first');
ltIdx = find(Parameters(UserRequestedPacket).Time>=UserRequestedTimes(2),1,'first');
if isempty(stIdx) || isempty(ltIdx)
    error('Could not figure out start/end indices for times [%.2f %.2f]',UserRequestedTimes);
end
if Parameters(UserRequestedPacket).Time(ltIdx)>UserRequestedTimes(2)
    ltIdx = ltIdx-1;
end
bins = Parameters(UserRequestedPacket).Bin([stIdx ltIdx]);
feats = cell(1,diff(bins)+1);

% pre-calculate indices from first bin
binVarName = sprintf('pkt%02d_bin%04d',UserRequestedPacket,bins(1));
bd = load(featfile,binVarName);
bin = bd.(binVarName);
freq_idx = bin.freq>=FrequencyBand(1) & bin.freq<=FrequencyBand(2);
chan_idx = ismember( Parameters(UserRequestedPacket).ChannelIDs,UserRequestedChannels );
time_idx = bin.time>=UserRequestedTimes(1) & bin.time<=UserRequestedTimes(2);
tmpfeats = double( bin.data( freq_idx, time_idx, chan_idx ) );

% check that all requested data will fit in memory
ElementsPerWindow = nnz(freq_idx) * nnz(chan_idx);
NumWindows =  ltIdx - stIdx + 1;
util.memcheck( NumWindows*ElementsPerWindow,'double',...
    'TotalUtilization',0.98,...
    'AvailableUtilization',0.98,...
    'assert','quiet');

% pre-allocate data and fill up first segment
feats = zeros(nnz(freq_idx),NumWindows,nnz(chan_idx));
feats(:, 1:nnz(time_idx), :) = tmpfeats;
featIdx = nnz(time_idx);
clear bd bin tmpfeats;

% loop over remaining bins
for bb = (bins(1)+1) : bins(2)
    
    % load bin data
    binVarName = sprintf('pkt%02d_bin%04d',UserRequestedPacket,bb);
    bd = load(featfile,binVarName);
    bin = bd.(binVarName);
    clear bd;
    
    % calculate indices for this bin
    time_idx = bin.time>=UserRequestedTimes(1) & bin.time<=UserRequestedTimes(2);
    
    % get data
    feats( :, featIdx + (1:nnz(time_idx)), : ) = double( bin.data( freq_idx, time_idx, chan_idx ) );
    featIdx = featIdx + nnz(time_idx);
end
time = Parameters(UserRequestedPacket).Time(stIdx:ltIdx);
freq = bin.freq(freq_idx);
