classdef BinFile < handle
% BINFILE Read data from a *.bin file containing NI daq samples
%
% This class is intended to read binary data from a *.bin data generated by
% NI.Interface (a class in the same package as this class). The binary data
% represent the digitized samples captured by the National Instruments
% hardware, and for its initial usage was intended to be used to record the
% monitoring outputs of the Blackrock stimulator. However, it is generally
% capable of working with any inputs.
%
% To use the BinFile class, provide a path to a *.bin file when creating
% the object:
%
% >> b = BinFile('/path/to/file.bin');
%
% Then, read from the file:
%
% >> [x,t] = b.read; % read all data
% >> [x,t] = b.read('time',[START END]); % read from START to END (seconds)
% >> [x,t] = b.read('channels',[CH1 CH2 ...]); % read only these channels
%
    properties(GetAccess=public,SetAccess=private)
        SamplingRate % sampling rate of the data
        NumChannels % number of channels recorded
        BytesPerSample % bytes per single-channel/single-sample
        DataClass % class of the data, e.g., single or double
        DataSections % 2-column array with [timestamp num_samples]
        NumBytesInHeaders = 9; % number of bytes in headers
        SourceDirectory % directory containing the file to read
        SourceBasename % basename of the file to read
        SourceExtension % file extension of the file to read
        SourceFileSize % size in bytes of the file to read
    end % END properties(GetAccess=public,SetAccess=private)
    methods
        function this = BinFile(varargin)
            % BINFILE Create object and process file headers
            %
            %   B = BINFILE('/path/to/file.bin');
            %   Create a BINFILE object to read from the specified binary
            %   data file. 
            idx = cellfun(@(x)ischar(x)&&exist(x,'file')==2,varargin);
            assert(any(idx),'Must provide path to existing file');
            srcfile = varargin{idx};
            varargin(idx) = [];
            util.argempty(varargin);
            
            % load basic information about the file
            [this.SourceDirectory,this.SourceBasename,this.SourceExtension] = fileparts(srcfile);
            info = dir(srcfile);
            this.SourceFileSize = info.bytes;
            
            % read the headers
            headers(this);
        end % END function BinFile
        
        function [x,t] = read(this,varargin)
            % READ Read data from the file
            %
            %   [X,T] = READ;
            %   Read all data from the binary file.
            %
            %   [X,T] = READ(...,'time',[START END]);
            %   Read data between START and END seconds.
            %
            %   [X,T] = READ(...,'channels',[CH1 CH2 ...]);
            %   Read data from the specified channels.
            %
            %   [X,T] = READ(...,'class',DATA_CLASS);
            %   Return data with the indicated data type DATA_CLASS.
            reqTime = [0 this.DataSections(end,1)+this.SamplingRate*this.DataSections(end,2)];
            [varargin,reqTime] = util.argkeyval('time',varargin,reqTime,4);
            reqChannels = 1:this.NumChannels;
            [varargin,reqChannels] = util.argkeyval('channels',varargin,reqChannels,2);
            [varargin,reqDataClass] = util.argkeyval('class',varargin,this.DataClass,5);
            assert(any(strcmpi(reqDataClass,{'uint8','int8','uint16','int16','uint32','int32','uint64','int64','single','double'})));
            util.argempty(varargin);
            
            % identify which data sections to read from
            idxDataSectionStart = find(this.DataSections(:,1)<=reqTime(1),1,'last');
            assert(~isempty(idxDataSectionStart),'Could not identify starting data section');
            idxDataSectionEnd = find(this.DataSections(:,1)>=reqTime(2),1,'first');
            if isempty(idxDataSectionEnd),idxDataSectionEnd=size(this.DataSections,1);end
            numDataSections = idxDataSectionEnd - idxDataSectionStart + 1;
            
            % construct time vector
            t = arrayfun(@(x)this.DataSections(x,1)+(0:(1/this.SamplingRate):(this.DataSections(x,2)/this.SamplingRate-1/this.SamplingRate)),idxDataSectionStart:idxDataSectionEnd,'UniformOutput',false);
            t = cat(2,t{:})';
            
            % open file for reading
            srcfile = fullfile(this.SourceDirectory,sprintf('%s%s',this.SourceBasename,this.SourceExtension));
            [fid,errmsg] = fopen(srcfile,'r');
            assert(fid>0,'Could not open source file ''%s'' for reading: %s',srcfile,errmsg);
            
            % read contents of file
            try
                
                % identify starting byte of first data section
                firstByte = this.NumBytesInHeaders;
                for kk=1:idxDataSectionStart-1
                    firstByte = firstByte + 8 + this.DataSections(kk,2)*this.NumChannels*this.BytesPerSample;
                end
                
                % move to first requested data section
                fseek(fid,firstByte,'bof');
                
                % process sections
                x = cell(numDataSections,1);
                currSection = 1;
                for kk=idxDataSectionStart:idxDataSectionEnd
                    fseek(fid,8,0); % skip past length and timestamp
                    %fprintf('Reading data section %d at byte %d\n',kk,ftell(fid));
                    
                    % read data out of the file
                    x{currSection} = fread(fid,[this.NumChannels this.DataSections(kk,2)],sprintf('*%s',this.DataClass));
                    x{currSection} = x{currSection}(reqChannels,:);
                    
                    % increment section pointer
                    currSection = currSection + 1;
                end
            catch ME
                fclose(fid);
                rethrow(ME);
            end
            
            % close the file
            fclose(fid);
            
            % post process the data sections
            x = cat(2,x{:})';
            if ~strcmpi(class(x),reqDataClass)
                x = cast(x,reqDataClass);
                t = cast(t,reqDataClass);
            end
            idx = t>=reqTime(1)&t<=reqTime(2);
            t = t(idx);
            x = x(idx,:);
        end % END function read
        
        function delete(this)
        end % END function delete
    end % END methods
    
    methods(Access=private)
        function headers(this)
            % HEADERS Process file headers
            srcfile = fullfile(this.SourceDirectory,sprintf('%s%s',this.SourceBasename,this.SourceExtension));
            [fid,errmsg] = fopen(srcfile,'r');
            assert(fid>0,'Could not open source file ''%s'' for reading: %s',srcfile,errmsg);
            
            % read the header bytes
            try
                bytes = fread(fid,9,'*uint8');
                this.SamplingRate = cast(typecast(bytes(1:4),'uint32'),'double');
                this.NumChannels = cast(typecast(bytes(5:6),'uint16'),'double');
                this.BytesPerSample = cast(typecast(bytes(7),'uint8'),'double');
                isFloatingPoint = cast(typecast(bytes(8),'uint8'),'double');
                isSigned = cast(cast(bytes(9),'uint8'),'double');
                switch this.BytesPerSample
                    case 1
                        assert(~isFloatingPoint,'Logical error: no 1-byte floating point data classes available');
                        if isSigned
                            this.DataClass = 'int8';
                        else
                            this.DataClass = 'uint8';
                        end
                    case 2
                        assert(~isFloatingPoint,'Logical error: no 2-byte floating point data classes available');
                        if isSigned
                            this.DataClass = 'int16';
                        else
                            this.DataClass = 'uint16';
                        end
                    case 4
                        if isFloatingPoint
                            this.DataClass = 'single';
                        elseif ~isFloatingPoint && isSigned
                            this.DataClass = 'int32';
                        elseif ~isFloatingPoint && ~isSigned
                            this.DataClass = 'uint32';
                        end
                    case 8
                        if isFloatingPoint
                            this.DataClass = 'double';
                        elseif ~isFloatingPoint && isSigned
                            this.DataClass = 'int64';
                        elseif ~isFloatingPoint && ~isSigned
                            this.DataClass = 'uint64';
                        end
                    otherwise
                        error('Only support 1, 2, 4, or 8 bytes per sample, not %d',this.BytesPerSample);
                end
                assert(~isempty(this.DataClass),'Could not identify the data class');
                
                % process sections
                this.DataSections = cell(10000,1);
                currSection = 1;
                nsamples = fread(fid,4,'*uint8');
                nsamples = cast(typecast(nsamples,'uint32'),'double');
                tstamp = fread(fid,4,'*uint8');
                tstamp = cast(typecast(tstamp,'single'),'double');
                this.DataSections{currSection} = [tstamp nsamples];
                while ~feof(fid)
                    currSection = currSection + 1;
                    nbytes = nsamples*this.NumChannels*this.BytesPerSample;
                    fseek(fid,nbytes,0);
                    nsamples = fread(fid,4,'*uint8');
                    nsamples = cast(typecast(nsamples,'uint32'),'double');
                    tstamp = fread(fid,4,'*uint8');
                    tstamp = cast(typecast(tstamp,'single'),'double');
                    this.DataSections{currSection} = [tstamp nsamples];
                end
                this.DataSections(currSection+1:end) = [];
                this.DataSections = cat(1,this.DataSections{:});
            catch ME
                fclose(fid);
                rethrow(ME);
            end
            
            % close the file
            fclose(fid);
        end % END function headers
    end % END methods(Access=private)
end % END classdef BinFile