classdef Decoder < handle
    properties
        
        % note that the properties structs divide into two categories, Params and
        % Props.  Params are things that the user defines.  Props are things that
        % are generated by the object.
        %
        % PARAMS
        % decoderParams     Params that govern the construction of the decoder
        % runtimeParams     Params the govern runtime operation of the decoder
        % frameworkParams   Params that govern interation with the framework and OS
        % guiParams         Params that govern construction and operation of GUI
        % idealAgentParams  Params that govern the Ideal Agent
        %
        % PROPS
        % signalProps       Properties of the information coming into the decoder object
        % decoderProps      Properties of the trained decoder
        % trainingProps     Properties of fits during training
        %
        % BASE PROPERTIES
        % bufferData
        % dataBuffers
        % isTrained
        
        hFramework
        
        name
        currentDecoderINDX
        
        decoderParams
        decoderParamsOrig
        runtimeParams
        frameworkParams
        guiParams
        idealAgentParams
        
        
        signalProps
        featureProps
        decoderProps
        trainingProps
        guiProps
        
        figureHandles
        
        decoders
        
        BufferData=0
        DataBuffers  % .IdealPrediction .NeuralPrediction .NeuralData .Kinematic .Goal
        isTrained % boolean : describing whether the the decoder has been trained.
        
        idealAgent
    end
    
    methods
        
        function obj=Decoder(defaultConfig,varargin)
            
            % default
            localConfig=[];
            featType=[];
            % Parse Inputs
            inputArguments=varargin;
            while ~isempty(inputArguments)
                
                switch inputArguments{1}
                    case 'hFramework'
                        obj.hFramework=inputArguments{2};
                        inputArguments(1:2)=[];
                    case 'localConfig'
                        localConfig=inputArguments{2};
                        inputArguments(1:2)=[];
                    case 'featType'
                        featType=inputArguments{2};
                        inputArguments(1:2)=[];
                        
                    otherwise
                        warning('Unrecognized arguement %s ... skipping',lower(inputArguments{1}))
                        inputArguments(1)=[];
                end
            end
            
            if ~isempty(obj.hFramework),obj.decoderParams.samplePeriod=obj.hFramework.options.timerPeriod; end
            
            obj=feval(defaultConfig,obj,localConfig);
            
            if isfield(obj.featureProps,'featType') && isempty(obj.featureProps.featType)
                obj.featureProps.featType=featType;
            end
            
            if isfield(obj.frameworkParams,'name')
                obj.name=obj.frameworkParams.name;
            end
            
%             if ~strcmp(computer,'MACI64')
% %                 Predictor.Decoder.openpool;
%             end
            
            obj.ConstructIdealAgent();
            obj.isTrained=0;
            
            % stuff to hold for realtime excecution
            obj.DataBuffers.RecentState         = Buffer.Circular(20*10);
            obj.DataBuffers.RecentGoal          = Buffer.Circular(20*10);
            obj.DataBuffers.RecentNeural        = Buffer.Circular(20*10);
            obj.DataBuffers.RecentResiduals     = Buffer.Circular(20*10);
            
            % stuff to strore for training 
            obj.DataBuffers.Goal                = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.IdealPrediction     = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.IdealForce          = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.NeuralData          = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.NeuralPrediction    = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.AssistedPrediction  = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.FrameID             = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            obj.DataBuffers.Kinematics          = Buffer.Circular(obj.runtimeParams.bufferCapacity);
            
            obj.frameworkParams.enableDecoder=1;
            
            if obj.guiParams.enableGUI
                gui(obj);
            end
            
            % position integrator
            obj.runtimeParams.pIntegrator=...
                util.blkdiagCell(repmat({[1 obj.decoderParams.samplePeriod; 0 1]},obj.decoderParams.nDOF,1));
            
            bufferFrameworkData(obj,1);
            
            if obj.guiParams.enableGUI
                handles = guihandles(obj.guiProps.handle);
                trainList=cellfun(@func2str,obj.decoderParams.batchTrainScript,'UniformOutput',false);
                set(handles.popupTrainSelect,'String',trainList);
                set(handles.popupTrainSelect,'Enable','on');
            end
            
            obj.decoderParamsOrig=obj.decoderParams;
        end
        
        function bufferFrameworkData(obj,init)
            if isfield(obj.frameworkParams,'BufferFunction') && ~isempty(obj.hFramework) && isa(obj.frameworkParams.BufferFunction,'function_handle')
                if nargin==2
                    feval(obj.frameworkParams.BufferFunction,obj,init);
                else
                    feval(obj.frameworkParams.BufferFunction,obj);
                end
            end
        end
        
        function StructOut=toStruct(obj)
            import util.getInputField
            
            % structs
            StructOut.decoders              = getInputField(obj,'decoders',    'decoderParams was not defined');
            StructOut.decoderParams         = getInputField(obj,'decoderParams',    'decoderParams was not defined');
            StructOut.signalProps           = getInputField(obj,'signalProps',      'signalProps was not defined');
            StructOut.decoderProps          = getInputField(obj,'decoderProps',     'decoderProps was not defined');
            StructOut.trainingProps         = getInputField(obj,'trainingProps',    'trainingProps was not defined');
            StructOut.idealAgentParams      = getInputField(obj,'idealAgentParams', 'idealAgentParams was not defined');
            StructOut.runtimeParams         = getInputField(obj,'runtimeParams',    'runtimeParams was not defined');
            StructOut.frameworkParams       = getInputField(obj,'frameworkParams',  'frameworkParams was not defined');
            StructOut.guiParams             = getInputField(obj,'guiParams',        'guiParams was not defined');
            
            
        end
        
        function fromStruct(obj,StructIn,decodersOnly)
            % if (obj.samplePeriod~=StructIn.samplePeriod)
            %     warning('LinearDecoder:StructIn', 'samplePeriod of obj (%f) and StructIn (%f) are not the same.  Cowardly refusing to transfer parameters as they will likely not generalize to the new sampling interval.',obj.samplePeriod,StructIn.samplePeriod)
            %     return
            % end
            %
            % if ~strcmp(obj.linearFilterType,StructIn.linearFilterType)
            %     warning('LinearDecoder:StructIn', 'linearFilterType of obj (%s) and StructIn (%s) are not the same.  This might lead to evil behavior.  Proceeding by overwriting obj.linearFilterType, Good luck and consider yourself warned.',obj.linearFilterType,StructIn.linearFilterType)
            % end
            % if (obj.nDOF~=StructIn.nDOF)
            %     warning('LinearDecoder:StructIn', 'nDOF of obj (%d) and StructIn (%d) are not the same.  This might lead to evil behavior.  Proceeding by overwiriting obj.nDOF, Good luck and consider yourself warned.',obj.nDOF,StructIn.nDOF)
            % end
            import util.getInputField
            if nargin==2
                decodersOnly=0;
            end
            
            % structs
            obj.decoders              = getInputField(StructIn,'decoders',   []);
            
            if ~decodersOnly || ~isfield(StructIn,'decoderParams')
                obj.decoderParams         = getInputField(StructIn,'decoderParams',    'decoderParams was not defined');
                obj.signalProps           = getInputField(StructIn,'signalProps',      'signalProps was not defined');
                obj.decoderProps          = getInputField(StructIn,'decoderProps',     'decoderProps was not defined');
                obj.trainingProps         = getInputField(StructIn,'trainingProps',    'trainingProps was not defined');
                obj.runtimeParams           = getInputField(StructIn,'runtimeParams',      'runtimeParams was not defined');
                obj.idealAgentParams        = getInputField(StructIn,'idealAgentParams',     'idealAgentParams was not defined');
                obj.guiParams               = getInputField(StructIn,'guiParams',    'guiParams was not defined');
            
            if isfield(obj.decoderParams,'updateFrameworkParams') && obj.decoderParams.updateFrameworkParams==1
                obj.frameworkParams           = getInputField(StructIn,'frameworkParams',      'frameworkParams was not defined');
            end
            
            
            end
            
            obj.isTrained=1;
            
        end
        
%     currentDecoderINDX: []        
%             idealAgent: [1x1 OptAgents.mjOptAgent]
%           featureProps: [1x1 struct]
%               guiProps: [1x1 struct]
%          figureHandles: []

% Decided
% %        frameworkParams: [1x1 struct]
% %          hFramework: []
% %                   name: []
% %          decoderParams: [1x1 struct]
% %          runtimeParams: [1x1 struct]
% %              guiParams: []
% %       idealAgentParams: [1x1 struct]
% %            signalProps: []
% %           decoderProps: []
% %          trainingProps: []
% %               decoders: []
% %             BufferData: 0
% %            DataBuffers: [1x1 struct]
% %              isTrained: 0

        
        function loadDecoder(obj,fileName,decodersOnly)
            if nargin==1 || isempty(fileName)
                filePath=obj.frameworkParams.savePath;
                [fileName,filePath]=uigetfile(fullfile(filePath ,'*_decoder.mat'),'Select Decoder File');
                
                if isequal(fileName,0)
                    return
                else
                    importData=load(fullfile(filePath,fileName));
                end
                
            else
                importData=load(fileName);
            end
            
            if nargin<3
                decodersOnly=0;
            end
            if ~isempty(importData)
                fromStruct(obj,importData.Decoders,decodersOnly);
            end
            
            if obj.guiParams.enableGUI
                decoderList = obj.listDecoders;
                handles = guihandles(obj.guiProps.handle);
                set(handles.popupDecoderSelect,'String',decoderList);
                set(handles.popupDecoderSelect,'Enable','on');
                set(handles.editDecoderName,'String',sprintf('Decoder-%0.2d',length(obj.decoders)));
            end
            
            obj.setDecoderINDX(1);
        end
        
        function saveDecoder(obj,saveName)
            
            if nargin<2
                saveName=fullfile(obj.frameworkParams.savePath,obj.frameworkParams.saveName);
            end
            
            Decoders=toStruct(obj);
            
            if iscell(saveName); saveName=saveName{1}; end
            obj.msgName(sprintf('Saving output to <a href="matlab:load(''%s'');">%s</a>',saveName,saveName));
            save(saveName,'Decoders')
            
        end
        
        function obj=ConstructIdealAgent(obj)
            % construct ideal agent if asked to
            if obj.idealAgentParams.make
                switch obj.idealAgentParams.type
                    case 'mjOptAgentV3'
                        obj.idealAgent=OptAgents.(obj.idealAgentParams.type)(obj.idealAgentParams.mvmntDuration,obj.decoderParams.samplePeriod,obj.decoderParams.nDOF);
                    case 'mjOptAgent'
                        obj.idealAgent=OptAgents.(obj.idealAgentParams.type)(obj.idealAgentParams.mvmntDuration,obj.decoderParams.samplePeriod);
                        case 'mjOptAgentV2'
                        obj.idealAgent=OptAgents.(obj.idealAgentParams.type)(obj.idealAgentParams.mvmntDuration,obj.decoderParams.samplePeriod,obj.idealAgentParams.dampingRadius);
                    case 'lqrOptAgent'
                        obj.idealAgent=eval(sprintf('OptAgents.%s', obj.idealAgentParams.type));
                                            case 'MousePosition'
                        obj.idealAgent=Framework.Predictor.MousePosition(obj.hFramework);
                    otherwise
                        error('Unsupported idealAgent Type')
                end
            end
        end
        
        function enableDecoder(obj)
            obj.frameworkParams.enableDecoder=1;
            obj.msgName('Decoder Enabled');
        end % END function enableDecoder
        
        function disableDecoder(obj)
            obj.frameworkParams.enableDecoder=0;
            obj.msgName('Decoder Disabled');
        end % END function disableDecoder
        
        function out=EnableSecondayAssist(obj)
            obj.runtimeParams.secondaryAssist.apply=not(obj.runtimeParams.secondaryAssist.apply);
            if obj.runtimeParams.secondaryAssist.apply
                obj.msgName(sprintf('Enabling Secondary Assist Enabled; Will Apply After %d Frames',obj.runtimeParams.secondaryAssist.waitPeriod));
            else
                obj.msgName('Disabling Secondary Assist');
            end
            out=obj.runtimeParams.secondaryAssist.apply;
        end
        
        function delete(this)
            if ~isempty(this.guiProps) && isfield(this.guiProps,'handle') && ishandle(this.guiProps.handle)
                close(this.guiProps.handle);
            end
            if this.runtimeParams.plotCursor && isfield(this.figureHandles,'CursorPlot') && ishandle(this.figureHandles.CursorPlot)
                close(this.figureHandles.CursorPlot);
            end
        end % END function delete
        
        function updateGUI(this)
            if ~isempty(this.guiProps) && isfield(this.guiProps,'handle') && ishandle(this.guiProps.handle)
                set(this.guiProps.guihandles.editBufferFill,'String',this.DataBuffers.NeuralData.numEntries);
                set(this.guiProps.guihandles.editSecondAssistLevel,'String',sprintf('%0.2f',this.runtimeParams.secondaryAssist.assistValue));
            end
        end % END function updateGUI
        
        function val = getAssistINDX(obj)
            switch obj.runtimeParams.assistType;
                case 'WeightedAverage'
                    val=1;
                case 'Projection'
                    val=2;
                case 'ErrorRailMag'
                    val=3;
                case 'ErrorRail'
                    val=4;
                otherwise
                    val=0;
            end
            
        end % END function getAssistINDX
        
        function val = getAssistLevel(this)
            val = this.runtimeParams.assistLevel(:)';
        end % END function getAssistLevel
        
        function val = getOutputGain(this)
            val = this.runtimeParams.outputGain(:)';
        end % END function getAssistLevel
        
    end % END methods
    
    methods(Static)
        
        function openpool(varargin)
            numcores=[];
            
            if(nargin==1)
                numcores=varargin{1};
            end
            
            warning('skipping')
%             if(matlabpool('size')~=numcores)
%                 if(matlabpool('size')>0)
%                     matlabpool('close');
%                 end
%                 matlabpool('open',numcores);
%             end
        end
        
        function cleanup
            ff = findobj('Name','DecoderGUI');
            if(any(~isempty(ff)) && any(ishandle(ff)))
                close(ff);
            end
        end
        
        % file defined static functions
        p=CompareFiringRates(Z,unitINDX)
        
        
    end
end

% should options be an object with fixed assignment?

% properties fo decode wrapper
%     availableDecoders - decoders that are available for decoding.
%     Determined by filterOptions
%     activeDecoders cell array of decodrs that are active (when calling predict, predictions will be determined by these set of decoders)


% methods
% raw2model % transforms raw features and reference data into the form
%             that will be used for model training and prediction.  E.G.
%             mean subtraction, Dim Reduction, non-linear combos (f1*f2,
%             f1^2), feature reduction.  feature reduction may occur based
%             on the results of training.  Thus prior to training,
%             raw2model may be underspecified.
% model2raw % inverse of above
% predict - spits out prediction
% train  - note: tain gets y and X ; what should be predicted

% model2train - constructs the regressors to use in the fitting functions


% featureSelction
% trainingInds