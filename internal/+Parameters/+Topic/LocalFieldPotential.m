function [topic,props] = LocalFieldPotential        

topic = struct(...
    'name','LFP Parameters',...
    'description','Parameters related to LFPs',...
    'id','lfp');

props.detrend = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to detrend the LFPs'));

props.detrendmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'detrendwin','dc_offset'})),...
    'default','dc_offset',...
    'attributes',struct('Description','''detrendwin'',''dc_offset'' method to use for detrending the data'));

props.detrendwin = struct(...
    'validationFcn',@(x)isnumeric(x)&&length(x)==2,...
    'default',[2 1],...
    'attributes',struct('Description','moving window values to use for detrending (win size, step size in seconds)'));

props.downsample = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to downsample the raw field potential time series'));

props.fs = struct(...
    'validationFcn',@isnumeric,...
    'default',2000,...
    'attributes',struct('Description','which sampling rate file to read from (typical options are 2000 (default) or 30000)'));

props.linenoise = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','attenuation of line noise'));

props.newfs = struct(...
    'validationFcn',@isnumeric,...
    'default',500,...
    'attributes',struct('Description','the target sampling rate when downsampling is enabled'));

props.norm = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to normalize the spectrogram'));

props.normsrc = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'baseline','same'})),...
    'default','baseline',...
    'attributes',struct('Description','''baseline'',''same'' source of data used to calculate normalizing parameters'));

props.normmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'zscore','minmax','adaptive','baseline'})),...
    'default','baseline',...
    'attributes',struct('Description','''zscore'',''minmax'',''adaptive'' method to use for normalization'));

props.normparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameters for normalization routine'));

props.regress = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to regress common elements out of the LFPs'));

props.rwindowed = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','regress out common elements in overlapping windows'));

props.rmode = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'concat','rdata','fdata'})),...
    'default','concat',...
    'attributes',struct('Description','''concat'',''rdata'',''fdata'' -- combine or select regressed/fitted data'));

props.rmovingwin = struct(...
    'validationFcn',@(x)isnumeric(x)&&length(x)==2,...
    'default',[0.25 0.15],...
    'attributes',struct('Description','size of moving window for windowed LFP regression'));

props.rsamples = struct(...
    'validationFcn',@isnumeric,...
    'default',1000,...
    'attributes',struct('Description','how many samples to use when estimating the linear model'));

props.reref = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','software-rereference'));

props.rerefmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'sqrt','log','atanh'})),...
    'default','sqrt',...
    'attributes',struct('Description','re-referencing method: dc_offset, car (common-average rereference)'));

props.smooth = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to the smooth the bin counts'));

props.smoothmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'mj','moving','lowess','loess','sgolay','rlowess','rloess'})),...
    'default','moving',...
    'attributes',struct('Description','method to use for smoothing the bin counts ''mj'',or any of the built-in method ''smooth'' methods'));

props.smoothparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameter to be passed to the smoothing method (all lower case fields of a struct)'));

props.timeavg = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to average bin counts over time (i.e. produce one average value for analysis window)'));

props.type = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'blc','nsx'})),...
    'default','blc',...
    'attributes',struct('Description','"blc" (default) or "nsx"'));

props.varstab = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','variance-stabilizing transformation'));

props.varstabmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'sqrt','log','atanh'})),...
    'default','sqrt',...
    'attributes',struct('Description','variance-stabilization method: sqrt, log, or atanh'));

props.varstabparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameters for variance-stabilizing transformation'));

props.units = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'noramlized', 'microvolts', 'millivolts', 'volts'})),...
    'default','microvolts',...
    'attributes',struct('Description','the units in which raw broadband data would be returned'));
    