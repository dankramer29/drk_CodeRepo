function [topic,props] = Spike

topic = struct(...
    'name','Spike Properties',...
    'description','Properties related to spikes',...
    'id','spk');

props.type = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'any','npmk','nev','sorted'})),...
    'default','any',...
    'attributes',struct('Description','''any'' (priority sorted > npmk > nev), ''npmk'' (MAT files with NPMK structs), ''nev'' (NEV file in root array directory), ''sorted'' (NEV file in SortedObjects subdirectory)'));

props.unsorted = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',true,...
    'attributes',struct('Description','include unsorted units (true) or exclude (false)'));

props.ignoresort = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','flag to ignore sorting assignments (true) or preserve them (false)'));

props.noise = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',true,...
    'attributes',struct('Description','include noise/hash unit (true) or exclude (false)'));

props.binwidth = struct(...
    'validationFcn',@isnumeric,...
    'default',0.05,...
    'attributes',struct('Description','the width of the bin used to calculate binned spike counts or firing rates'));

props.ts = struct(...
    'validationFcn',@isnumeric,...
    'default',[],...
    'attributes',struct('Description','utility field to allow calculation of the minimum interval between spike timestamps (see e.g. proc.raster)'));

props.fs = struct(...
    'validationFcn',@isnumeric,...
    'default',30e3,...
    'attributes',struct('Description','utility field to allow specifying the spike sampling rate'));

props.varstab = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',true,...
    'attributes',struct('Description','variance-stabilizing transformation'));

props.varstabmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'sqrt','log','atanh'})),...
    'default','sqrt',...
    'attributes',struct('Description','variance-stabilization method: sqrt, log, or atanh'));

props.varstabparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameters for variance-stabilizing transformation'));

props.norm = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','normalize the bin counts'));

props.normsrc = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'baseline','same'})),...
    'default','baseline',...
    'attributes',struct('Description','''baseline'',''same'' source of data used to calculate normalizing parameters'));

props.normmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'zscore','minmax'})),...
    'default','zscore',...
    'attributes',struct('Description','normalization method: ''zscore'', ''minmax'''));

props.normparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameters for normalization routine'));

props.timeavg = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to average bin counts over time (i.e. produce one average value for analysis window)'));

props.ratefilt = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to filter features based on their bin counts (firing rates)'));

props.ratefiltmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'mean','median','max','min'})),...
    'default','mean',...
    'attributes',struct('Description','method to use for rate-filtering the features'));

props.ratefiltparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameters for rate filtering'));

props.smooth = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to the smooth the bin counts'));

props.smoothmethod = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'mj','moving','lowess','loess','sgolay','rlowess','rloess'})),...
    'default','moving',...
    'attributes',struct('Description','method to use for smoothing the bin counts ''mj'',or any of the built-in method ''smooth'' methods'));

props.smoothparams = struct(...
    'validationFcn',@(x)true,...
    'default',[],...
    'attributes',struct('Description','parameter to be passed to the smoothing method (all lower case fields of a struct)'));

props.bin2fr = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','convert bin counts to firing rates'));

props.downsample = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','whether to downsample the spike timestamps'));

props.newfs = struct(...
    'validationFcn',@isnumeric,...
    'default',500,...
    'attributes',struct('Description','the target sampling rate when downsampling is enabled'));

props.timestampunits = struct(...
    'validationFcn',@(x)ischar(x)&&any(strcmpi(x,{'samples','seconds'})),...
    'default','samples',...
    'attributes',struct('Description','the units of spike timestamps (''samples'' or ''seconds'')'));