function [topic,props] = SpikeSort

topic = struct(...
    'name','Spike Sort Properties',...
    'description','Properties related to spike detection and sorting',...
    'id','spksrt');

props.threshold_filter = struct(...
    'validationFcn',@(x)iscell(x)||ischar(x),...
    'default',{'butter_o8_bp_250-5000'},...
    'attributes',struct('Description','Name of filter to use prior to thresholding the data for spike detection (or cell array of names of filters to run serially)'));

props.causal_filtering = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','Whether to perform causal or noncausal filtering when thresholding spike data'));

props.thresh = struct(...
    'validationFcn',@isnumeric,...
    'default',-4,...
    'attributes',struct('Description','Threshold for spike detection, in units of estimated standard deviation of the background noise'));

props.refractory = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0005,...
    'attributes',struct('Description','Refractory period to impose when detecting spikes (in sec)'));

props.chanlimit = struct(...
    'validationFcn',@isnumeric,...
    'default',10,...
    'attributes',struct('Description','Limit the number of channels a threshold crossing may appear on before being rejected as artifact'));

props.chanlimitwin = struct(...
    'validationFcn',@isnumeric,...
    'default',5,...
    'attributes',struct('Description','Any timestamps occurring within this number of samples on other channels will count toward the rejection limit'));

props.waveform_samples = struct(...
    'validationFcn',@isnumeric,...
    'default',48,...
    'attributes',struct('Description','Number of samples to save for each waveform'));

props.samples_before_thresh = struct(...
    'validationFcn',@isnumeric,...
    'default',11,...
    'attributes',struct('Description','Number of samples prior to the threshold crossing'));

props.thresh_append = struct(...
    'validationFcn',@ischar,...
    'default','thresh',...
    'attributes',struct('Description','String to append to the re-thresholded NEV filename'));

props.thresh_overwrite = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',false,...
    'attributes',struct('Description','Whether to allow the thresholding software to overwrite existing files'));

props.car = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',true,...
    'attributes',struct('Description','apply common-average re-reference transformation'));

props.car_channels = struct(...
    'validationFcn',@(x)isnumeric(x),...
    'default',1:96,...
    'attributes',struct('Description','Which channels to use when computing the common average'));
    