function [topic,props] = Time        

topic = struct(...
    'name','Time Properties',...
    'description','Properties related to timing',...
    'id','tm');

props.baseline = struct(...
    'validationFcn',@(x)iscell(x)||ischar(x)||isnumeric(x),...
    'default','',...
    'attributes',struct('Description','time window to use for baseline (relative to trial) (or name of phase) (empty for nothing)'));

props.analysis = struct(...
    'validationFcn',@(x)iscell(x)||ischar(x)||isnumeric(x),...
    'default','',...
    'attributes',struct('Description','time window to use for analysis (relative to trial) (or phase name or cell array of phase names) (empty for full trial)'));

props.lenfcn = struct(...
    'validationFcn',@(x)ischar(x)||isa(x,'function_handle'),...
    'default',@(x)x,...
    'attributes',struct('Description','function to determine length for each trial based on lengths for all trials; should accept vector of lengths, and produce a single value or a vector of lengths'));

props.bufferpre = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0,...
    'attributes',struct('Description','amount of time to read before the start of the phase (for filtering etc.; specify w.r.t. beginning of analysis window)'));

props.discardpre = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0,...
    'attributes',struct('Description','amount of time to discard at the beginning of the analysis window (prior to averaging, analysis etc.; specify w.r.t. beginning of analysis window)'));

props.bufferpost = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0,...
    'attributes',struct('Description','amount of time to read after the end of the analysis window (for filtering etc.; specify w.r.t. beginning of analysis window)'));

props.discardpost = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0,...
    'attributes',struct('Description','amount of time to discard at the end of the analysis window (prior to averaging, analysis etc.; specify w.r.t. beginning of analysis window)'));

props.min = struct(...
    'validationFcn',@isnumeric,...
    'default',0.0,...
    'attributes',struct('Description','minimum amount of data required to remain after removing buffer/discard from pre/post'));

props.dt = struct(...
    'validationFcn',@isnumeric,...
    'default',0.05,...
    'attributes',struct('Description','sampling interval in the returned features'));

props.sync = struct(...
    'validationFcn',@(x)islogical(x)||(isnumeric(x)&&(x==1||x==0)),...
    'default',true,...
    'attributes',struct('Description','incorporate the optical sync offset if available'));

props.ambiguous = struct(...
    'validationFcn',@(x)isa(x,'function_handle')||(ischar(x)&&any(strcmpi(x,{'ignore','warn','error','keyboard'}))),...
    'default','error',...
    'attributes',struct('Description','how to handle ambiguous timing requests in the neural data (NEV - multiple matching recording blocks; NSx - multiple matching recording packets)'));