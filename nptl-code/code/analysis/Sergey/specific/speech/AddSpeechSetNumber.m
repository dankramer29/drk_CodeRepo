% AddSpeechSetNumber.m
%
% Looks through a constructed speech R struct and labels each trial based on its setnumber
% *within that R struct*. It does so by looking at whether the .clock values are
% contiguous (they'll be slightly overlapping within a set due to the way
% trialifySpeechBlock.m works). Since the pause between sets is longer than the hanging
% ends around each trial, sets will be separated by non-contiguous .clock.
% 
% This function is fairly brittle and is designed to work with the constructed R structs
% that most of these analyses use. 
% In different situations, use the audio text logs generated by the laptop during the cued
% speech experiments.
%
% USAGE: [ R ] = AddSpeechSetNumber( R, varargin )
%
% EXAMPLE: R = AddSpeechSetNumber( R );
%
% INPUTS:
%     R                         speech R struct, generated by trailifySpeechBlock.m which
%                               is called by WORKUP_prepareSpeechBlock.m. Don't throw away
%                               trials from the R (e.g. wrong labels) to avoid incorrectly
%                               splitting up sets.
%                               Should have a .blockNumber from trialifySpeechBlock.m;
%                               otherwise, can't trust just .clock because it's not unique
%                               across blocks.
%   OPTIONAL ARGUMENT-VALUE PAIRS: 
%                               
%
% OUTPUTS:
%     R                         R struct with a .pseudoSet . pseudo to clarify that these
%                               aren't necessarily the sets as presented.
%
% Created by Sergey Stavisky on 28 Dec 2017 using MATLAB version 9.3.0.713579 (R2017b)

 function [ R ] = AddSpeechSetNumber( R, varargin )
    def.fieldName = 'pseudoSet';
    assignargs( def, varargin);
 
    runningSet = 1;
    % assign first trial to set 1 no matter what
    R(1).(fieldName) = runningSet;
    % loop through remaining trials.
    for i = 2 : numel( R )
        % if there was a block break, then definitely start a new set
        if R(i).blockNumber ~= R(i-1).blockNumber
            runningSet = runningSet + 1;
            R(i).(fieldName) = runningSet;
            continue
        end
        
        % do we overlap with last tril's .clock?
        prevTrialLastClock = R(i-1).clock(end);
        myFirstClock = R(i).clock(1);
        if myFirstClock <= prevTrialLastClock
            % same set
            
        else
            runningSet = runningSet + 1;
        end
        R(i).(fieldName) = runningSet;        
    end
end