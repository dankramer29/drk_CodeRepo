% Looks at the instructed breathing dataset, and plots aligned to 
%
% The R struct was previously generated by makeInstructedBreathingRstruct.m
%
% Sergey Stavisky 16 January 2019
clear


datFile = [ResultsRoot '/speech/breathing/instructed[9 10 11 12 13 14 15 16 17 18 19 20 21 22 23].mat'];
participant = 't5';


% Neural feature:
params.RMSmult = -4.5;

params.thresholdRMS = -4.5; % spikes happen below this RMS
params.neuralFeature = 'spikesBinnedRateGaussian_25ms'; % spike counts binned smoothed with 25 ms SD Gaussian 


params.startEvent = 'goCue - 1.4';
params.alignEvent = 'goCue';
params.endEvent = 'goCue + 3';

colors = [1 0 0;
    0 0 1];

% from instructed breathing mod depth analysis (breath-aligned)
plotChannels = [49; 171; 136; 177;    97;103;186;188;187]; % avg chans, strong chans

% Some aesthetics
FaceAlpha = 0.3; % 

%% 
% Load data
in = load( datFile );
R = in.R;
clear('in');

%%
% Apply threshold
rms = channelRMS( R );
R = RastersFromMinAcausSpikeBand( R, params.thresholdRMS.*rms );
R = AddFeature( R, params.neuralFeature  );


%%

allLabels = {R.label};

% generate PSTHs for the two trial types (breathe in and breathe out)


% track channels with < 1 Hz
liveChans = [];

uniqueLabels = unique( {R.label} );
for iLabel = 1 : numel( uniqueLabels )
    myLabel = uniqueLabels{iLabel};
    myTrialInds = strcmp( allLabels, myLabel );
    jenga = AlignedMultitrialDataMatrix( R(myTrialInds), 'featureField', params.neuralFeature, ...
        'startEvent', params.startEvent, 'alignEvent', params.alignEvent, 'endEvent', params.endEvent );
    result.(myLabel).t = jenga.t;
    result.(myLabel).psthMean = squeeze( mean( jenga.dat, 1 ) );
    result.(myLabel).psthStd = squeeze( std( jenga.dat, 1 ) );
    for t = 1 : size( jenga.dat,2 )
        result.(myLabel).psthSem(t,:) =  sem( squeeze( jenga.dat(:,t,:) ) );
    end
    result.(myLabel).numTrials = jenga.numTrials;
    
    epochFR = squeeze( nanmean( nanmean( jenga.dat, 1), 2 ) ) / (jenga.numSamples/1000);
    liveChans = [liveChans, find( epochFR >= 1 )];
end
liveChans = unique(liveChans);


timeGo = mode( [R.goCue] );
timeReturn = mode( [R.returnCue] );
if strcmp( params.alignEvent, 'goCue' )
    goTimeS = 0;
    returnTimeS = (timeReturn - timeGo)/1000;
end

%% Plot example trial PSTHs
for iCh = 1 : numel( plotChannels )
    chanInd = plotChannels(iCh);
    figh = figure;
    figh.Color = 'w';
    titlestr = sprintf('breath psth %i', chanInd);
    figh.Name = titlestr;
    axh = axes;
    hold on;
    myMax = 0; % will be used to track max FR across all conditions.
    xlabel(['Time ' params.alignEvent ' (s)']);

    for iLabel = 1 : numel( uniqueLabels )
        myLabel = uniqueLabels{iLabel};
        myX = result.(myLabel).t;
        myY = result.(myLabel).psthMean(:,chanInd);
        myMax = max([myMax, max( myY )]);
        plot( myX, myY, 'Color', colors(iLabel,:), ...
            'LineWidth', 1 );
        
        mySem = result.(myLabel).psthSem(:,chanInd);
        [px, py] = meanAndFlankingToPatchXY( myX, myY, mySem );
        h = patch( px, py, colors(iLabel,:), 'FaceAlpha', FaceAlpha, ...
            'EdgeColor', 'none');        
        myMax = max([myMax, max( myY+mySem )]);
               
        % PRETTIFY
        % make horizontal axis nice
        xlim([myX(1), myX(end)])
        % make vertical axis nice
        ylabel( params.neuralFeature, 'Interpreter', 'none' );      
        set( axh, 'TickDir', 'out' )
    end
    
    myYlim = [0 ,ceil( myMax ) + 1];
    ylim( myYlim );
    
    % go line
    line([goTimeS, goTimeS], myYlim, 'Color', 'g', 'LineWidth', 2 );
    % return line
    line([returnTimeS, returnTimeS], myYlim, 'Color', 'k' );

    % add legend
    MakeDumbLegend( uniqueLabels, 'Color', colors );
end



%% Across-channel firing rates
fprintf('%i channels with FR > 1 Hz\n', numel( liveChans ) );
figh = figure;
figh.Color = 'w';
titlestr = sprintf('Grand mean FR instructed breathing');
figh.Name = titlestr;
axh = axes;
hold on;
myMax = 0; % will be used to track max FR across all conditions.
myMin = inf;
xlabel(['Time ' params.alignEvent ' (s)']);

for iLabel = 1 : numel( uniqueLabels )
    myLabel = uniqueLabels{iLabel};
    myX = result.(myLabel).t;
    
    myY = mean( result.(myLabel).psthMean(:,liveChans), 2 ) ;
    
    plot( myX, myY, 'Color', colors(iLabel,:), ...
        'LineWidth', 1 );
 
    
    % PRETTIFY
    % make horizontal axis nice
    xlim([myX(1), myX(end)])
    % make vertical axis nice
    ylabel( params.neuralFeature, 'Interpreter', 'none' );
    set( axh, 'TickDir', 'out' )
end

myYlim = axh.YLim;

% go line
line([goTimeS, goTimeS], myYlim, 'Color', 'g', 'LineWidth', 2 );
% return line
line([returnTimeS, returnTimeS], myYlim, 'Color', 'k' );

% add legend
MakeDumbLegend( uniqueLabels, 'Color', colors );

%% PCA
bigDat = [ result.breathe_in.psthMean ; result.breathe_out.psthMean ];
[coeff,score,~, ~, explained] = pca( bigDat );
figure; plot( cumsum( explained ) );


figh = figure;
figh.Color = 'w';
titlestr = sprintf('breath PCA Trial Avg');
figh.Name = titlestr;
for iPC = 1 : 6
    axh = subplot(2,3,iPC);
    hold on;
    xlabel(['Time ' params.alignEvent ' (s)']);
    title( sprintf('PC%i (%.1f%%)', iPC, explained(iPC) ) );
    for iLabel = 1 : numel( uniqueLabels )
        myLabel = uniqueLabels{iLabel};
        myX = result.(myLabel).t;
        
        myY =  coeff(:,iPC)' * result.(myLabel).psthMean';
        
        plot( myX, myY, 'Color', colors(iLabel,:), ...
            'LineWidth', 1 );        
        
        % PRETTIFY
        % make horizontal axis nice
        xlim([myX(1), myX(end)])
        % make vertical axis nice
        set( axh, 'TickDir', 'out' )
    end
    if iPC == 1
        MakeDumbLegend( uniqueLabels, 'Color', colors );
    end     
    
    myYlim = axh.YLim;
    % go line
    line([goTimeS, goTimeS], myYlim, 'Color', 'g', 'LineWidth', 2 );
    % return line
    line([returnTimeS, returnTimeS], myYlim, 'Color', 'k' );
end