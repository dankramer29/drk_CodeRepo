% Projects speech PSTH into the decoder-potent subspace of the Radial 8 Task data
% collected on the same day. Also projects the Radial 8 trajectories into the same
% dimensions to give a scale for this.
%
% Sergey D. Stavisky, Stanford Neural Prosthetics Translational Laboratory, October 24 2018
%
% CRITICAL NOTE: Does not yet do bias offset correction. Needs that for these neural pushes
% to be accurate.
%
% Analysis details:
% Looks at outward Radial 8 Trials

clear
%% Analysis parameters
error('IMPLEMENT BIAS OFFSET')
% For getting Radial 8 Task PSTHs
% for T5
params.r8Start = 'timeTargetOn-0.050';
params.r8Align = 'timeTargetOn';
params.r8End = 'timeTargetOn+0.600';
% for T8:
params.r8StartBins = 0; % from target on
t8binMS = 20; % according to Frank
params.r8EndBins = 600/t8binMS; % 20 ms bins

params.neuralFeature = 'spikesBinnedRateGaussian_25ms'; % spike counts binned smoothed with 25 ms SD Gaussian; matched to PSTHs in speech dynamics manuscript
% params.neuralFeature = 'spikesBinnedRate_20ms'; % ought to be matched to the Words datasets

% %% point to t5.2017.10.25 data
% participant = 't5';
% % t5.2017.10.25 block 12 and 14 are the R8 blocks
% data.streamFiles = {...
%     [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/FileLogger/12/'];
%     [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/FileLogger/14/'];
%     };
% % Open-loop data
% % data.streamFiles = {...
% %     [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/FileLogger/10/'];
% %     };
% % data.decoderFile = [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/Filters/001-blocks010-thresh-4.5-ch60-bin15ms-smooth25ms-delay60ms.mat']; % from open loop
% data.decoderFile = [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/Filters/002-blocks011-thresh-4.5-ch60-bin15ms-smooth25ms-delay0ms.mat']; % from closed loop data
% % the words PSTHs need to have been previously generated by prepWordPSTHsForDecoderPotent.m
% data.wordsFile = '/Users/sstavisk/Results/speech/psths/t5_2017_10_25-words_spikesBinnedRateGaussian_25ms_handResponseEvent - 1_0_handResponseEvent + 1';

%% point to t5.2018.12.12 data
participant = 't5';
% t5.2018.12.12 block 
data.streamFiles = {...
    [CachedDatasetsRootNPTL '/NPTL/t5.2018.12.12/Data/FileLogger/5/']; % block 5 is vanilla R8 block
    };
% Open-loop data
% data.streamFiles = {...
%     [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/FileLogger/10/'];
%     };
data.decoderFile = [CachedDatasetsRootNPTL '/NPTL/t5.2018.12.12/Data/Filters/002-blocks004-thresh-4.5-ch80-bin15ms-smooth25ms-delay0ms.mat']; %ReFIT
% the words PSTHs need to have been previously generated by prepWordPSTHsForDecoderPotent.m
% same RMS as decoder above:
data.wordsFile = '/Users/sstavisk/Results/speech/psths/t5_2018_12_12-words_noRaw_spikesBinnedRateGaussian_25ms_handResponseEvent - 0_5_handResponseEvent + 0_5.mat';
% -4.5 x RMS
% data.wordsFile = '/Users/sstavisk/Results/speech/psths/RMS4_5/t5_2018_12_12-words_noRaw_spikesBinnedRateGaussian_25ms_handResponseEvent - 0_5_handResponseEvent + 0_5.mat';

%% point to t5.2018.12.17 data
% participant = 't5';
% % t5.2018.12.17 block 6
% data.streamFiles = {...
%     [CachedDatasetsRootNPTL '/NPTL/t5.2018.12.17/Data/FileLogger/6/']; % block 6 is vanilla R8 block
%     };
% % Open-loop data
% % data.streamFiles = {...
% %     [CachedDatasetsRootNPTL '/NPTL/t5.2017.10.25/Data/FileLogger/10/'];
% %     };
% data.decoderFile = [CachedDatasetsRootNPTL '/NPTL/t5.2018.12.17/Data/Filters/002-blocks004-thresh-4.5-ch80-bin15ms-smooth25ms-delay0ms.mat']; %ReFIT
% % the words PSTHs need to have been previously generated by prepWordPSTHsForDecoderPotent.m
% %threhsold based on above decoder:
% data.wordsFile = '/Users/sstavisk/Results/speech/psths/t5_2018_12_17-words_noRaw_spikesBinnedRateGaussian_25ms_handResponseEvent - 0_5_handResponseEvent + 0_5.mat';
% % threshold at -4.5 RMS (Same as decoder, but could account for shifts over time)
% % data.wordsFile = '/Users/sstavisk/Results/speech/psths/RMS4_5/t5_2018_12_17-words_noRaw_spikesBinnedRateGaussian_25ms_handResponseEvent - 0_5_handResponseEvent + 0_5.mat';

%% Point to T8 data
% params.neuralFeature = 'spikesBinnedRate_20ms'; % ought to be matched to the Words datasets
% participant = 't8';
% data.wordsFile = '/Users/sstavisk/Results/speech/psths/t8_2017_10_18-words_spikesBinnedRate_20ms_handResponseEvent - 1_0_handResponseEvent + 1';
% data.streamFiles = {...
%     [CachedDatasetsRootNPTL '/NPTL/t8.2017.10.18/Data/SLC Data/PC1/SLCdata_2017_1018_155221(4).mat'];
%     [CachedDatasetsRootNPTL '/NPTL/t8.2017.10.18/Data/SLC Data/PC1/SLCdata_2017_1018_155650(5).mat'];
%     };
% data.decoderFile = [CachedDatasetsRootNPTL '/NPTL/t8.2017.10.18/Data/NCS Data/Blocks_Single_2017.10.18.16.00_(5).mat'];



%% Load Radial 8 Task data
% Generate Radial 8 PSTHs


        
% Load data
switch participant
    case 't5'
        R = [];
        for iBlock = 1 : numel( data.streamFiles )
            Rin = onlineR( parseDataDirectoryBlock( data.streamFiles{iBlock} ) ); % includes minACausSpikeBand
            fprintf('Loaded %i cursor task trials\n', numel( Rin ) );
            R = [R, Rin];
        end
    case 't8'
        allTargPos = [];
        allTX = [];
        for iBlock = 1 : numel( data.streamFiles )
            in = load( data.streamFiles{iBlock} );
            myTargPos = double( in.task.goal.values(:,1:2) );
            myTX = in.ncTX.values;
            allTargPos = [allTargPos; myTargPos];
            allTX = [allTX; myTX];
            blockThresholds{iBlock} = in.sSLC.features.ncTX.min_threshold(1,:);
        end
end
        
        
% Load Decoder
decoder = load( data.decoderFile );
ncs = decoder; % preserve Frank's nomenclature
fprintf('Loaded decoder %s\n', pathToLastFilesep( data.decoderFile, 1 ) );

switch participant
    case 't5'
        % get thresholds from decoder
        thresholds = decoder.model.thresholds;
        % get decoder-potent veloicty projector
        velProjector = decoder.model.minDim.K(decoder.model.reducedVelDims,: );
        velProjector = velProjector(:,1:numel(thresholds))'; % spikes only, chans x 2
    case 't8'
        thresholds = blockThresholds{1}; % will focus on just 1 (note: in practice they are the same);
        txMeans = ncs.singleBlock.sSLCsent.decoders.kalman.ncTXMeans;
        txStandardDeviations = 1./ncs.singleBlock.sSLCsent.decoders.kalman.ncTXNorm;
        ncTXInds = ncs.singleBlock.sSLCsent.decoders.kalman.ncTXInds;
        M2 = zeros(2,192);
        M2(:,ncTXInds) = ncs.singleBlock.sSLCsent.decoders.kalman.K_pad(1:2,1:length(ncTXInds));
        velProjector = M2';
        % Get the spike power M2 matrix; not relevant to the analysis as I currently envision it
        % but useful to compare it to the threshold crossings M2. I'm guessing more neural push
        % comes from the spikes power band.
        spInds = ncs.singleBlock.sSLCsent.decoders.kalman.spikePowerInds;
        M2spikePower = ncs.singleBlock.sSLCsent.decoders.kalman.K_pad(1:2,(length(ncTXInds)+1):(length(ncTXInds)+length(spInds)));
end


%% Load the Words data
in = load( data.wordsFile );
wordsRes = in.result;
clear('in');
% warn if neural features aren't the same
if ~strcmp( wordsRes.params.neuralFeature, params.neuralFeature )
    fprintf( 2, 'Warning: different neural features between Words and R8 analyses: %s vs %s\n', ...
        wordsRes.params.neuralFeature,params.neuralFeature )
end

%% Prepare aligned Radial 8 task data for outward going trials
%  (Analysis pipeline basically taken from humanCursorPosOneDataset.m)
switch participant
    case 't5'
        % remove very first R8 trial, since it has a odd lastPosTarget
        R8 = R;
        R8(1) = [];
        fprintf('Starting with %i R8 task trials\n', numel( R8 ) );
        % Restrict to successful trials
        R8 = R8([R8.isSuccessful]);
        fprintf(' %i successful trials\n', numel( R8 ) );
        
        % Divide by condition.
        inInds = CenteringTrialInds( R8 );
        R8(inInds) = [];
        
        
        [targetIdx, uniqueTargets] = SortTrialsByTarget( R8 );
        cmapR8 = hsv( size( uniqueTargets, 1 ) );
        
        eachTrialColors = nan( numel( targetIdx ), 3 );
        for iTrial = 1 : numel( R8 )
            R8(iTrial).condition = targetIdx(iTrial);
            % generate single-trial colors
            STcolor(iTrial,1:3) = cmapR8(targetIdx(iTrial),:);
        end
        uniqueR8conds = unique( [R8.condition]);
        fprintf('%i unique R8 conditions\n', numel( uniqueR8conds ) );
        
        
        figh_cursorTrajectories = OverheadTrajectories_NPTL( R8, 'colors', STcolor );
        figh_cursorTrajectories = ConvertToWhiteBackground( figh_cursorTrajectories );
        titlestr = sprintf('R8 Overheads %s', dataset );
        figh_cursorTrajectories.Name = titlestr;
        
        
        R8 = RastersFromMinAcausSpikeBand( R8, thresholds );
        R8 = AddFeature( R8, params.neuralFeature ); % create the spiking feature
        jenga = AlignedMultitrialDataMatrix( R8, 'featureField', params.neuralFeature , ...
            'startEvent', params.r8Start  , 'alignEvent', params.r8Align, 'endEvent', params.r8End  );
        jenga.dat(:,1,:) = []; % trim the first sample which tends to be nan-y
        jenga.t(1) = [];
        jenga.numSamples = jenga.numSamples-1;
        
        
        maxNormEachR8Condition = [];
        for iCond = 1 : numel( uniqueR8conds )
            thisCondTrials = [R8.condition] == uniqueR8conds(iCond);
            result.R8.t{iCond} = jenga.t;
            result.R8.psthMean{iCond} = squeeze( mean( jenga.dat(thisCondTrials,:,:), 1 ) );
            result.R8.psthStd{iCond} = squeeze( std( jenga.dat(thisCondTrials,:,:), 1 ) );
            for t = 1 : size( jenga.dat,2 )
                result.R8.psthSem{iCond}(t,:) =  sem( squeeze( jenga.dat(thisCondTrials,t,:) ) );
            end
            result.R8.numTrials(iCond) = nnz( thisCondTrials );
            % channel names had best be the same across events/groups, so put them in one place
            result.R8.channelNames = R8(find(thisCondTrials, 1, 'first')).(params.neuralFeature).channelName;
            
            % Projection into decoder-potent space
            result.R8.decoderPotent{iCond} = result.R8.psthMean{iCond} * velProjector;
            
            % record maximum norm for this condition
            myNorm = norms( result.R8.decoderPotent{iCond}' );
            maxNormEachR8Condition(iCond) = max( myNorm );
        end

    case 't8'
        %first, code each trial based on the target position
        theta = linspace(0,2*pi,9);
        theta = theta(1:8);
        targList = [cos(theta)', sin(theta)']*14 + [0,40.5];
        cmapR8 = hsv( size( targList, 1 ) );

        targOnset = find(any(abs(diff(allTargPos)),2))+1;
        trlTargPos = allTargPos(targOnset+5,:);
        targCodes = nan(length(trlTargPos),1);
        for iTrial = 1 : length( targCodes )
            err = norms( [targList - trlTargPos(iTrial,:)]' );
            [minErr,minIdx] = min(err);
            if minErr<0.01
                targCodes(iTrial) = minIdx;
            end
        end
        
        outReaches = find(ismember(targCodes, [1:8])); % indices to the outward reach trials       
        uniqueR8conds = unique( targCodes( outReaches ) );
        fprintf('%i total trials across %i outward reach conditions\n', numel( outReaches ), numel( uniqueR8conds ) );
        
        
        maxNormEachR8Condition = [];
        for iCond = 1 : numel( uniqueR8conds )
            thisCondTrialInds = find( targCodes == uniqueR8conds(iCond) );
            
            
            result.R8.t{iCond} = 0 : t8binMS : params.r8EndBins*t8binMS;
            % create neural data for this condition, trial by trial
            % it will be trial x (time bin) x channels
            myDatMat = nan( numel( thisCondTrialInds ), numel( result.R8.t{iCond} ), size( allTX, 2 ) );
            for iTrial = 1 : numel( thisCondTrialInds )
                thisTrialInd = thisCondTrialInds(iTrial);
                % my start bin is target on
                myTargOn = targOnset(thisTrialInd);
                myDatMat(iTrial,:,:) = allTX(myTargOn:myTargOn+numel( result.R8.t{iCond} )-1,:);                
            end
            
            result.R8.psthMean{iCond} = squeeze( mean( myDatMat, 1 ) );
            result.R8.psthStd{iCond} = squeeze( std( myDatMat, 1 ) );
            for t = 1 : numel( result.R8.t{iCond} )
                result.R8.psthSem{iCond}(t,:) =  sem( squeeze( myDatMat(:,t,:) ) );
            end
            result.R8.numTrials(iCond) = numel( thisCondTrialInds );
                       
            % Projection into decoder-potent space
            % note: the CWRU decoders apparently need features to be z-scored before applying M2,
            % so that's why i do this below
            
            myZscoredTx = [result.R8.psthMean{iCond} - repmat( txMeans, size( result.R8.psthMean{iCond}, 1),  1 )];
            myZscoredTx = myZscoredTx ./ repmat( txStandardDeviations, size( result.R8.psthMean{iCond}, 1),  1 );
            result.R8.decoderPotent{iCond} = myZscoredTx * velProjector;
            
            % record maximum norm for this condition
            myNorm = norms( result.R8.decoderPotent{iCond}' );
            maxNormEachR8Condition(iCond) = max( myNorm );
        end
        
end





%% Project Words into decoder-potent subspace
maxNormEachWordCondition = [];
wordsConds = wordsRes.uniqueLabels;
silenceInd = find( strcmp( wordsConds, 'silence' ) );
for iWord = 1 : numel( wordsConds )
    myLabel = wordsConds{iWord};
    
    % Projection into decoder-potent space
    result.words.t = wordsRes.(myLabel).t;    
    switch participant
        case 't5'
            result.words.decoderPotent{iWord} = wordsRes.(myLabel).psthMean * velProjector;
        case 't8'
            % z score as per their decoders' expectations
            myZscoredPSTH = [wordsRes.(myLabel).psthMean - repmat( txMeans, size( wordsRes.(myLabel).psthMean, 1 ), 1 )];
            myZscoredPSTH = myZscoredPSTH ./ repmat( txStandardDeviations, size( wordsRes.(myLabel).psthMean, 1),  1 );
            result.words.decoderPotent{iWord} = myZscoredPSTH * velProjector;
    end
    result.words.psthMean{iWord} = wordsRes.(myLabel).psthMean;
    
    % record maximum norm for this condition
    myNorm = norms( result.words.decoderPotent{iWord}' );
    maxNormEachWordCondition(iWord) = max( myNorm );
end

%% Sanity check 1: mean firing rates for each channel in the words and R8 datasets.
% This can reveal if, for instance, the thresholdin
% is way off or if the units don't match (e.g., if firing rates vs spike counts).

allR8 = cell2mat( result.R8.psthMean' );
meanR8 = nanmean( allR8, 1 );

allWords = cell2mat( result.words.psthMean' );
meanWords = nanmean( allWords, 1 );


figh = figure;
figh.Name = 'Mean Rate';
figh.Color = 'w';
axh = axes; hold on;
plot( meanR8, 'Color', 'k' );
plot( meanWords, 'Color', 'b' );
xlabel('Channel');
ylabel('Firing Rate (Hz)')
legend( {'Radial 8','Words'} )

%% Sanity check 2: plot neural push in 2D space
figh = figure;
figh.Name = 'Neural push 2D overhead';
figh.Color = 'w';
axh = axes; hold on;
for iCond = 1 : numel( uniqueR8conds )    
    if exist( 'targList', 'var')
        maxPush = max( reshape( abs( cell2mat( result.R8.decoderPotent' ) ), [], 1 ) );
        %direction of this target, but normalize to neural pushes and re-center (needed for R8,
        %their coordinate system doesn't seem zero-centered)
        myTarg = targList(iCond,:) - [mean( targList(:,1) ), mean( targList(:,2) )];
        myDirVec = myTarg./norm( myTarg ).* (1/sqrt(2)*maxPush);
        line([0 myDirVec(1)], [0, myDirVec(2)], 'LineWidth', 3, 'Color', cmapR8(iCond,:) );
    end
    plot( result.R8.decoderPotent{iCond}(:,1), result.R8.decoderPotent{iCond}(:,2), 'Color', cmapR8(iCond,:) );
end
axis equal
xlabel('Neural Push X')
ylabel('Neural Push Y')
%% Plot Neural push magnitude 
% Plot time-varying neural push for Radial 8 Task PSTHs
figh = figure;
figh.Color = 'w';
axh_R8 = subplot(2,4,1:3);
hold on;
for iCond = 1 : numel( uniqueR8conds )    
    plot( result.R8.t{iCond}, norms( result.R8.decoderPotent{iCond}' ), 'Color', cmapR8(iCond,:) );
end
firstNonNan = find( ~isnan( norms( result.R8.decoderPotent{iCond}' ) ), 1, 'first' );
xlim( [result.R8.t{iCond}(firstNonNan), result.R8.t{iCond}(end) ] );
xlabel( sprintf( 'Seconds after %s', params.r8Align ) );
ylabel( 'Neural Push Magnitude' );

% Plot maximum norm, mean +- std across the R8 conditions
meanMaxNorm = mean( maxNormEachR8Condition );
stdMaxNorm = std( maxNormEachR8Condition );
axh_barplots = subplot( 2, 4, [4] );
xlim([0.5 2.5]);
axh_barplots.XTickLabel = {'R8', 'words'};
axh_barplots.TickDir = 'out';
lh = line( [1 1], [0 meanMaxNorm], 'Color', [.5 .5 .5], 'LineWidth', 10 );
lh = line( [1 1], [meanMaxNorm-stdMaxNorm meanMaxNorm+stdMaxNorm], 'Color', [0 0 0], 'LineWidth', 2 );


% Plot time-varying neural push magnitude for words data
axh_words = subplot(2,4,5:7);
hold on;
for iCond = 1 : numel( wordsConds )    
    myColor = speechColors( wordsConds{iCond} );
    plot( result.words.t, norms( result.words.decoderPotent{iCond}' ), 'Color', myColor );
end
wordsAlignEvent = strrep( wordsRes.params.alignEvent, 'handResponseEvent', 'VOT');
xlabel( sprintf( 'Seconds after %s', wordsAlignEvent ) );
ylabel( 'Neural Push Magnitude' );

% link axes
linkaxes( [axh_R8, axh_words], 'y' );

% Plot maximum norm, mean +- std across the Words conditions 
% Don't include silence
axes( axh_barplots );
includedNorms = maxNormEachWordCondition;
includedNorms(silenceInd) = [];
meanMaxNorm = mean( includedNorms );
stdMaxNorm = std( includedNorms );
lh = line( [2 2], [0 meanMaxNorm], 'Color', [.3 .3 .3], 'LineWidth', 10 );
lh = line( [2 2], [meanMaxNorm-stdMaxNorm meanMaxNorm+stdMaxNorm], 'Color', [0 0 0], 'LineWidth', 2 );





%% plot neural push magnitude as separate X and Y
% this is to rule out that it's somehow rapidly oscillating between + and - which to a KF
% would smooth to near zero
figh = figure;
figh.Color = 'w';
% R8 trajectories
axh_top = subplot( 2, 1, 1 );  hold on;
for iCond = 1 : numel( uniqueR8conds )   
    plot( result.R8.t{iCond}, result.R8.decoderPotent{iCond}(:,1), 'Color', cmapR8(iCond,:) );
    plot( result.R8.t{iCond}, result.R8.decoderPotent{iCond}(:,2), 'LineStyle', '--', 'LineWidth', 1.5, 'Color', cmapR8(iCond,:) );
end
firstNonNan = find( ~isnan( norms( result.R8.decoderPotent{iCond}' ) ), 1, 'first' );
xlim( [result.R8.t{iCond}(firstNonNan), result.R8.t{iCond}(end) ] );
xlabel( sprintf( 'Seconds after %s', params.r8Align ) );
ylabel( 'Neural Push (signed)' );

% Words
axh_bottom = subplot(2, 1, 2);
hold on;
for iCond = 1 : numel( wordsConds )    
    myColor = speechColors( wordsConds{iCond} );
    plot( result.words.t,  result.words.decoderPotent{iCond}(:,1), 'Color', myColor );
    plot( result.words.t,  result.words.decoderPotent{iCond}(:,2), 'LineStyle', '--', 'LineWidth', 1.5, 'Color', myColor );
end
ylabel( 'Neural Push (signed)' );
xlabel( sprintf( 'Seconds after %s', wordsAlignEvent ) );

linkaxes( [axh_top, axh_bottom], 'y' );

