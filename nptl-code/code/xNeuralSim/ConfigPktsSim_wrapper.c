/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Fri Sep 27 13:57:47 2013
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <stdio.h> // memcpy
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
 
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void ConfigPktsSim_Outputs_wrapper(const int32_T *continue_in,
                          const uint32_T *clk,
                          const uint8_T *start,
                          const uint16_T *cbhwverMajor,
                          const uint16_T *cbhwverMinor,
                          int32_T *continue_out,
                          uint8_T *pktData,
                          real_T *pktSize)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/*
 * This code sends all the necessary config packets to describe a
 * 96 channel nsp w/ continuous 30KHz data and spikes.
 * It sends 106 packets (96 ch, 5 group, 1 filt, 1 bank, 1 proc, 1 runlevel
 * and 1 response).
 *
 * N. Schmansky, March 2012
 */

#include <cbhwlib_lite.h>

#define PROC_NUM 1

/*
 * output each necessary config packet within a state machine. 
 * The (non-real-time) UDP block only stores two packets of data
 * per time step, as the background task is responsible for actually
 * sending the packet, so we use this state machine to send all the
 * packets over multiple time steps.
 */

static int state=0;
static unsigned int groupNum=0;
static unsigned int channelNum=0;

UINT32 sysclk = clk[0]; // input sysclock 30KHz
pktSize[0] = 0; // assume no data to send

if ((start[0] == 1) && (continue_in[0] == 0))
{
    // begin the state machine
    state = 0;
}
else if (continue_in[0] == 1)
{
    // we're in the middle of the state machine
}
else
{
    // the 'do nothing' state
    state = -1;
    continue_out[0] = 0;
}
    
if (state == 0) // send responseconfigall packet
{
    cbPKT_GENERIC* respConfigAllPkt = (cbPKT_GENERIC*)pktData;
    memset(respConfigAllPkt,0,sizeof(cbPKT_GENERIC));
    respConfigAllPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    respConfigAllPkt->type = cbPKTTYPE_REPCONFIGALL;
    respConfigAllPkt->time = sysclk;
    
    pktSize[0] = (respConfigAllPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    ++state; // goto next state (next packet to send)
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 1) // send RUNNING run-level packet
{
    cbPKT_SYSINFO* sysInfoPkt = (cbPKT_SYSINFO*)pktData;
    memset(sysInfoPkt,0,sizeof(cbPKT_SYSINFO));
    sysInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    sysInfoPkt->type = cbPKTTYPE_SYSREP;
    sysInfoPkt->dlen = cbPKTDLEN_SYSINFO;
    sysInfoPkt->runlevel = cbRUNLEVEL_RUNNING; // set to runlevel RUNNING
    sysInfoPkt->sysfreq = 30000; // 30KHz
    sysInfoPkt->time = sysclk;
    
    pktSize[0] = (sysInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    ++state; // goto next state (next packet to send)
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 2) // send processor info packet
{
    cbPKT_PROCINFO* procInfoPkt = (cbPKT_PROCINFO*)pktData;
    memset(procInfoPkt,0,sizeof(cbPKT_PROCINFO));
    procInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    procInfoPkt->type = cbPKTTYPE_PROCREP;
    procInfoPkt->dlen = cbPKTDLEN_PROCINFO;
    // custom proc info:
    sprintf_s(procInfoPkt->ident, 64, "xPC %dch NSP Simulator",NUM_SIM_CHANNELS);
    procInfoPkt->proc = PROC_NUM;
    procInfoPkt->idcode = 256;
    procInfoPkt->chanbase = 1;
    procInfoPkt->chancount = NUM_SIM_CHANNELS;
    procInfoPkt->bankcount = 1;
    procInfoPkt->groupcount = 5;
    procInfoPkt->version = (cbhwverMajor[0] << 16) | (cbhwverMinor[0]);
    procInfoPkt->time = sysclk;
    
    pktSize[0] = (procInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    ++state; // goto next state (next packet to send)
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 3) // send bank info packet
{
    cbPKT_BANKINFO* bankInfoPkt = (cbPKT_BANKINFO*)pktData;
    memset(bankInfoPkt,0,sizeof(cbPKT_BANKINFO));
    bankInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    bankInfoPkt->type = cbPKTTYPE_BANKREP;
    bankInfoPkt->dlen = cbPKTDLEN_BANKINFO;
    // custom bank info:
    sprintf_s(bankInfoPkt->ident, 64, "Bank 1");
    sprintf_s(bankInfoPkt->label, 16, "Front End A");
    bankInfoPkt->proc = PROC_NUM;
    bankInfoPkt->bank = 1;
    bankInfoPkt->chanbase = 1;
    bankInfoPkt->chancount = NUM_SIM_CHANNELS;
    bankInfoPkt->idcode = 256;
    bankInfoPkt->time = sysclk;
    
    pktSize[0] = (bankInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    ++state; // goto next state (next packet to send)
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 4) // send filter info packet
{
    cbPKT_FILTINFO* filtInfoPkt = (cbPKT_FILTINFO*)pktData;
    memset(filtInfoPkt,0,sizeof(cbPKT_FILTINFO));
    filtInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    filtInfoPkt->type = cbPKTTYPE_FILTREP;
    filtInfoPkt->dlen = cbPKTDLEN_FILTINFO;
    filtInfoPkt->proc = PROC_NUM;
    filtInfoPkt->time = sysclk;
    
    pktSize[0] = (filtInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    ++state; // goto next state (next packet to send)
    groupNum = 0; // make sure these are zeroed
    channelNum = 0;
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 5) // send group info packets (five of them)
{
    int ch;
    cbPKT_GROUPINFO* groupInfoPkt = (cbPKT_GROUPINFO*)pktData;
    memset(groupInfoPkt,0,sizeof(cbPKT_GROUPINFO));
    groupInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    groupInfoPkt->type = cbPKTTYPE_GROUPREP;
    groupNum++; // send packets for five groups
    groupInfoPkt->group = groupNum;
    groupInfoPkt->proc = PROC_NUM;
    groupInfoPkt->time = sysclk;
    
    // custom info:
    switch (groupNum)
    {
    case 1:
      groupInfoPkt->dlen = cbPKTDLEN_GROUPINFOEMP;
      sprintf_s(groupInfoPkt->label, 16, "500 S/s");
      groupInfoPkt->period = 60;
      groupInfoPkt->length = 0;
      break;
    case 2:
      groupInfoPkt->dlen = cbPKTDLEN_GROUPINFOEMP;
      sprintf_s(groupInfoPkt->label, 16, "1 kS/s");
      groupInfoPkt->period = 30;
      groupInfoPkt->length = 0;
      break;
    case 3:
      groupInfoPkt->dlen = cbPKTDLEN_GROUPINFOEMP;
      sprintf_s(groupInfoPkt->label, 16, "2 kS/s");
      groupInfoPkt->period = 15;
      groupInfoPkt->length = 0;
      break;
    case 4:
      groupInfoPkt->dlen = cbPKTDLEN_GROUPINFOEMP;
      sprintf_s(groupInfoPkt->label, 16, "10 kS/s");
      groupInfoPkt->period = 3;
      groupInfoPkt->length = 0;
      break;
    case 5:
    default:
      sprintf_s(groupInfoPkt->label, 16, "30 kS/s");
      groupInfoPkt->period = 1; // our sysclock is a 30KHz clock
      // all our channels are in group 5: 30K
      groupInfoPkt->length = NUM_SIM_CHANNELS;
      groupInfoPkt->dlen = cbPKTDLEN_GROUPINFOEMP + groupInfoPkt->length;
      for (ch=1; ch<= NUM_SIM_CHANNELS; ch++)
      {
        groupInfoPkt->list[ch-1] = ch; 
      }
      break;
    }
        
    pktSize[0] = (groupInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    if (groupNum == 5)
    {
        groupNum = 0;
        ++state; // goto next state (next packet to send)
    }
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else if (state == 6) // send channel info packets (96 of them)
{
#if 1
    cbPKT_CHANINFO* chanInfoPkt = (cbPKT_CHANINFO*)pktData;
    memset(chanInfoPkt,0,sizeof(cbPKT_CHANINFO));
    channelNum++;
    // channel config: 96 channels, spiking enabled, sample group 5 (30K)
    chanInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
    chanInfoPkt->type = cbPKTTYPE_CHANREPSMP;
    chanInfoPkt->dlen = cbPKTDLEN_CHANINFO;
    chanInfoPkt->proc = PROC_NUM;
    chanInfoPkt->bank = 1;
    chanInfoPkt->smpgroup = 5;
    chanInfoPkt->chancaps = cbCHAN_EXISTS | 
                            cbCHAN_CONNECTED | 
                            cbCHAN_ISOLATED | 
                            cbCHAN_AINP; // 0x00000107 <- from observations
                                         // of CentralSim settings in cbbg
    chanInfoPkt->ainpcaps = cbAINP_SPKPROC;
                            //cbAINP_RAWPREVIEW | 
                            //cbAINP_SMPSTREAM | 
                            //cbAINP_SPKSTREAM | 
                            // 0x00000F37;     ""
    chanInfoPkt->ainpopts = 0;              // 0x00000100;     ""
    chanInfoPkt->spkcaps  = cbAINPSPK_EXTRACT; // 0x0003F00F;  ""
    chanInfoPkt->spkopts  = 0;              // 0x00010100;     ""

    // physical channel scaling information
    chanInfoPkt->physcalin.digmin = 0x8004; 
    chanInfoPkt->physcalin.digmax = 0x7ffc; 
    chanInfoPkt->physcalin.anamin = 0xffffe001; 
    chanInfoPkt->physcalin.anamax = 0x00001fff; 
    chanInfoPkt->physcalin.anagain = 0x00000001; 
    sprintf_s(chanInfoPkt->physcalin.anaunit, 8, "uV");
    
    sprintf_s(chanInfoPkt->label, 16, "ch%d", channelNum);
    chanInfoPkt->chan = channelNum;
    chanInfoPkt->time = sysclk;
    
    pktSize[0] = (chanInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    if (channelNum == NUM_SIM_CHANNELS)
    {
        channelNum = 0;
        ++state; // goto next state (next packet to send, if any)
    }
#else
    ++state;
#endif
    continue_out[0] = 1; // not done with loop, keep looping thru states
}
else
{
    state = -1; // we're the do-nothing state
    continue_out[0] = 0; // done with loop, stop looping thru states
    pktSize[0] = 0; // no data to send over udp
}
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
