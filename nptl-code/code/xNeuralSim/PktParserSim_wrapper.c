/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Fri Mar 15 07:32:27 2013
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <stdio.h> // memcpy
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
 
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void PktParserSim_Outputs_wrapper(const uint32_T *clk,
                          const uint8_T *data,
                          const real_T *size,
                          uint8_T *sendConfigPkts,
                          uint8_T *responsePktData,
                          real_T *responsePktSize,
                          uint8_T *setRunlevelPktData,
                          real_T *setRunlevelPktSize,
                          int32_T *running)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/*
 * This code parses packets arriving from UDP port 1002 
 * and sends packets to UDP port 1002.
 * Handles system (heartbeat and config), sample and spike data pkts.
 *
 * N. Schmansky, June 2012
 */

#include <cbhwlib_lite.h>

static unsigned int runlevel=0;

/*
 * begin parsing loop, filling output pkt data as needed
 */

int bytes = (int)size[0];
unsigned char* recv_buf = (unsigned char*)&data[0];

// Where is the current packet within the receive buffer?
int offset = 0;

// How many bytes do we have left to process in the receive buffer?
int bytes_to_process = bytes;

// outputs:
// assume no packets processed (so zero response packets to send)
sendConfigPkts[0] = 0;
responsePktSize[0] = 0;
setRunlevelPktSize[0] = 0;
// running[0] = set =1 when RUNNING level request received;

while (bytes_to_process)
{
    cbPKT_GENERIC *pktptr = (cbPKT_GENERIC*)(recv_buf+offset);

    // If this packet extends past the end of the receive buffer...
    int packet_size = (pktptr->dlen) * 4 + cbPKT_HEADER_SIZE;
    if (packet_size + offset > bytes)
    {
      // if this happens, recv_buf needs to be increased
      break;
    }

    bytes_to_process -= packet_size;
    offset += packet_size;

    // parse and handle

    if (pktptr->type == cbPKTTYPE_REQCONFIGALL)
    {
        sendConfigPkts[0] = 1; // trigger ConfigPkts while loop subsystem
    }
    else if (pktptr->type == cbPKTTYPE_SYSSETRUNLEV)
    {
        // setup and send RUNNING run-level packet
        cbPKT_SYSINFO* setrunlevelPkt = (cbPKT_SYSINFO*)pktptr;
        cbPKT_SYSINFO* sysInfoPkt = (cbPKT_SYSINFO*)&setRunlevelPktData[0];
        if (setrunlevelPkt->runlevel == cbRUNLEVEL_HARDRESET)
        {
            sendConfigPkts[0] = 1; // trigger ConfigPkts while loop subsystem
            runlevel = 1; // enable sending of sample data
        }
        sysInfoPkt->chid = CEREBUS_SYSPACKET_CHANNEL;
        sysInfoPkt->type = cbPKTTYPE_SYSREP;
        sysInfoPkt->dlen = cbPKTDLEN_SYSINFO;
        sysInfoPkt->resetque = setrunlevelPkt->resetque;
        sysInfoPkt->runflags = setrunlevelPkt->runflags;
        sysInfoPkt->runlevel = cbRUNLEVEL_RUNNING; // switch to runlevel RUNNING
        sysInfoPkt->spikelen = setrunlevelPkt->spikelen;
        sysInfoPkt->spikepre = setrunlevelPkt->spikepre;
        sysInfoPkt->sysfreq = 30000; // 30KHz
        setRunlevelPktSize[0] = (sysInfoPkt->dlen * 4) + cbPKT_HEADER_SIZE;
    }
    else // echo response packet back to sender (Central expects one)
    {
        // only type and time are updated
        cbPKT_GENERIC* ppkt = (cbPKT_GENERIC*)&responsePktData[0];
        responsePktSize[0] = (pktptr->dlen * 4) + cbPKT_HEADER_SIZE;
        memcpy(ppkt,pktptr,responsePktSize[0]);
        ppkt->type = pktptr->type & 0x7F; // response bit is 0x80 cleared
        ppkt->time = clk[0];
    }
}

running[0] = runlevel; // if running==1, enable sample data sender subsystem
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
